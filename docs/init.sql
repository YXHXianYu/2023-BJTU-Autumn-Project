/*
 Navicat Premium Data Transfer

 Source Server         : MySQL
 Source Server Type    : MySQL
 Source Server Version : 80032 (8.0.32)
 Source Host           : localhost:3306
 Source Schema         : peer_learning_system

 Target Server Type    : MySQL
 Target Server Version : 80032 (8.0.32)
 File Encoding         : 65001

 Date: 21/12/2023 21:33:44
*/

CREATE DATABASE IF NOT EXISTS peer_learning_system;
USE peer_learning_system;

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for grouphomework
-- ----------------------------
DROP TABLE IF EXISTS `grouphomework`;
CREATE TABLE `grouphomework`  (
  `uuid` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `name` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `problemUUID` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `state` int NULL DEFAULT NULL,
  `submitDeadline` date NULL DEFAULT NULL,
  `ratingDeadline` date NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE,
  UNIQUE INDEX `unique_name`(`name` ASC) USING BTREE,
  INDEX `problemUUID`(`problemUUID` ASC) USING BTREE,
  CONSTRAINT `grouphomework_ibfk_1` FOREIGN KEY (`problemUUID`) REFERENCES `problem` (`uuid`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of grouphomework
-- ----------------------------
INSERT INTO `grouphomework` VALUES ('33689bad-e7a2-4e8a-b506-51991a1d44a3', 'Demo 快速选择作业', '12a5200f-e5c0-436b-9bf0-57e896f55b27', 0, '2023-12-25', '2024-01-18');
INSERT INTO `grouphomework` VALUES ('6c2c50ce-4dcb-4503-bf04-c425cbf5ace5', '操作系统-实验3：批处理与特权级', '5eb01691-b618-4921-b377-05fddca08205', 2, '2023-11-27', '2023-11-29');
INSERT INTO `grouphomework` VALUES ('aa2b4cd1-9ef8-450a-b7a8-1adaebd65714', 'Demo Homework', '5eb01691-b618-4921-b377-05fddca08205', 1, '2023-11-27', '2023-11-29');
INSERT INTO `grouphomework` VALUES ('bfeaedb2-7ab8-48c2-a03d-27a22b01fc4b', 'Demo 手动选择学生', '12a5200f-e5c0-436b-9bf0-57e896f55b27', 0, '2023-12-28', '2023-12-30');

-- ----------------------------
-- Table structure for homework
-- ----------------------------
DROP TABLE IF EXISTS `homework`;
CREATE TABLE `homework`  (
  `uuid` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `groupHomeworkUUID` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `userUUID` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `answer` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL,
  `isExcellentHomework` tinyint(1) NULL DEFAULT NULL,
  `haveChecked` tinyint(1) NULL DEFAULT NULL,
  `checkedScore` float NULL DEFAULT -1,
  `isNeedToCheck` tinyint(1) NULL DEFAULT 0,
  `recheckReason` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL,
  `recheckDetailedReason` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL,
  PRIMARY KEY (`uuid`) USING BTREE,
  INDEX `groupHomeworkUUID`(`groupHomeworkUUID` ASC) USING BTREE,
  INDEX `userUUID`(`userUUID` ASC) USING BTREE,
  CONSTRAINT `homework_ibfk_1` FOREIGN KEY (`groupHomeworkUUID`) REFERENCES `grouphomework` (`uuid`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `homework_ibfk_2` FOREIGN KEY (`userUUID`) REFERENCES `user` (`uuid`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of homework
-- ----------------------------
INSERT INTO `homework` VALUES ('01d6226b-b23c-4209-87fc-551172b4fce8', '33689bad-e7a2-4e8a-b506-51991a1d44a3', '0dbe2bc7-533a-470c-8047-44da0fa5a9a0', '', 0, 0, 0, 0, '', '');
INSERT INTO `homework` VALUES ('142b79db-5528-4d8d-b5cf-c125eaf8c288', '6c2c50ce-4dcb-4503-bf04-c425cbf5ace5', 'eb341724-a0f9-41c8-8d21-191f2a632509', '# 操作系统 实验3<br><br>> 21301114 俞贤皓<br>><br>> 环境（实验0~2）：Arch Linux 6.5.3-arch1-1<br>><br>> 环境（实验3）：Ubuntu 22.04.3 LTS (WSL)<br><br>答案！', 1, 0, 100, 1, '互评得分错误', '我觉得其他同学的评分有问题。在第一题中，我的答案和标准答案一模一样！我希望我能获得满分。');
INSERT INTO `homework` VALUES ('216128c6-b105-436d-adfe-d7a612607c3d', 'bfeaedb2-7ab8-48c2-a03d-27a22b01fc4b', '84effa11-e2e0-4514-a0fe-9a893bb4e12e', '', 0, 0, 0, 0, '', '');
INSERT INTO `homework` VALUES ('2244aa4e-6336-4f97-a07f-77b5cd597eea', 'bfeaedb2-7ab8-48c2-a03d-27a22b01fc4b', '0dbe2bc7-533a-470c-8047-44da0fa5a9a0', '', 0, 0, 0, 0, '', '');
INSERT INTO `homework` VALUES ('260bec8b-a5ad-4a5d-83dd-0036e4a18b96', '6c2c50ce-4dcb-4503-bf04-c425cbf5ace5', '3360539a-0c69-4535-982b-16775a6ea1f1', '', 0, 0, 10, 0, NULL, NULL);
INSERT INTO `homework` VALUES ('4d409db2-6a01-40b4-97e3-50c55aec52e9', '6c2c50ce-4dcb-4503-bf04-c425cbf5ace5', '0dbe2bc7-533a-470c-8047-44da0fa5a9a0', '我是Guest，请给我打高分！', 1, 0, 29, 1, NULL, NULL);
INSERT INTO `homework` VALUES ('4f68779b-372b-4148-ae16-6b7305cc5efd', 'bfeaedb2-7ab8-48c2-a03d-27a22b01fc4b', '2fabe48e-65ad-4564-9f19-2959b9eb5827', '', 0, 0, 0, 0, '', '');
INSERT INTO `homework` VALUES ('6fdc0263-7d92-4b6d-971c-5c17587d43ee', 'aa2b4cd1-9ef8-450a-b7a8-1adaebd65714', 'eb341724-a0f9-41c8-8d21-191f2a632509', '===========<br>Answer<br>===========', 0, 0, 0, 1, '未被互评', '11111111111');
INSERT INTO `homework` VALUES ('7875270e-4726-4da3-9070-f4abdbe752f9', 'aa2b4cd1-9ef8-450a-b7a8-1adaebd65714', '2e278e29-537a-4ee9-807b-8fc379abd82d', '', 1, 0, 0, 0, NULL, NULL);
INSERT INTO `homework` VALUES ('7b08baa4-6358-4c00-993c-e04ff9e4dbcd', '33689bad-e7a2-4e8a-b506-51991a1d44a3', '2fabe48e-65ad-4564-9f19-2959b9eb5827', '', 0, 0, 0, 0, '', '');
INSERT INTO `homework` VALUES ('934626a9-5c1a-4dc3-b5cd-33a4126dca0f', 'aa2b4cd1-9ef8-450a-b7a8-1adaebd65714', '56ecfad5-a97f-403f-90bb-b5979bda179e', '==========<br>StudentA Answer<br>=========', 0, 0, 0, 0, NULL, NULL);
INSERT INTO `homework` VALUES ('959585a3-05fb-468b-a4e9-96f41c5decec', '33689bad-e7a2-4e8a-b506-51991a1d44a3', 'eb341724-a0f9-41c8-8d21-191f2a632509', '', 0, 0, 0, 0, '', '');
INSERT INTO `homework` VALUES ('9657821b-5ea1-4eb8-96c3-ac70bfa3ab4c', 'bfeaedb2-7ab8-48c2-a03d-27a22b01fc4b', 'eb341724-a0f9-41c8-8d21-191f2a632509', '', 0, 0, 0, 0, '', '');
INSERT INTO `homework` VALUES ('9a31a8a6-c482-4ea1-8194-9928458425f8', '6c2c50ce-4dcb-4503-bf04-c425cbf5ace5', '84effa11-e2e0-4514-a0fe-9a893bb4e12e', '', 0, 0, 20.5, 0, NULL, NULL);
INSERT INTO `homework` VALUES ('c0c3dbc9-14fa-4797-a5d9-278a7bbd81bf', 'aa2b4cd1-9ef8-450a-b7a8-1adaebd65714', '50724553-9222-4786-a6dc-844c56efe9e4', '', 0, 0, 0, 0, NULL, NULL);
INSERT INTO `homework` VALUES ('c4b2a5db-1a92-4399-bcd6-f5e252be7654', '33689bad-e7a2-4e8a-b506-51991a1d44a3', '84effa11-e2e0-4514-a0fe-9a893bb4e12e', '', 0, 0, 0, 0, '', '');
INSERT INTO `homework` VALUES ('d03cbfc1-24bd-4d3a-8c07-acf81c2e4073', 'bfeaedb2-7ab8-48c2-a03d-27a22b01fc4b', '3360539a-0c69-4535-982b-16775a6ea1f1', '', 0, 0, 0, 0, '', '');
INSERT INTO `homework` VALUES ('e09321f1-e06b-4ecc-9fba-58dacc3fb36a', '6c2c50ce-4dcb-4503-bf04-c425cbf5ace5', '2fabe48e-65ad-4564-9f19-2959b9eb5827', '', 0, 0, 10.3333, 0, NULL, NULL);
INSERT INTO `homework` VALUES ('f7c8a033-12b1-4dee-b9e4-cf3b5524722d', '33689bad-e7a2-4e8a-b506-51991a1d44a3', '3360539a-0c69-4535-982b-16775a6ea1f1', '', 0, 0, 0, 0, '', '');

-- ----------------------------
-- Table structure for problem
-- ----------------------------
DROP TABLE IF EXISTS `problem`;
CREATE TABLE `problem`  (
  `uuid` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `name` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL,
  `standardAnswer` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL,
  PRIMARY KEY (`uuid`) USING BTREE,
  UNIQUE INDEX `unique_name`(`name` ASC) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of problem
-- ----------------------------
INSERT INTO `problem` VALUES ('12a5200f-e5c0-436b-9bf0-57e896f55b27', '数字运输-2', '小卷卷最近又获取了一批数字 $(1\\le p \\le 2\\times 10^{5})$，他打算将这些数字发送给小龙龙。<br><br>但是他的流量不够了，所以他决定通过进制转换，使用足够小的空间发送这些数字。<br><br>对于每个数字 $p$，设其在 $q(q \\ge 2)$ 进制下的表示为 $\\overline{x\\_1x\\_2...x\\_s}$，那么传输这个数字需要的空间包括两部分：$m \\times s$ 的占位空间，其中 $m$ 为常数；以及 $\\sum\\_{i=1}^s x\\_i$ 的数字空间。所需的总空间为两者之和。<br><br>小卷卷给你所要传输的数字，需要设定一个进制 $q(q \\ge 2)$，使得在 $q$ 进制下的每个数传输空间之和最小，请给出最小传输空间。', '输入的第一行为两个整数 $n,m\\ (1\\le n,m\\le 10^{5})$，代表数字个数和占位空间常数。<br>第二行为$n$个整数，代表要传输的数字 $p_i\\ (1\\le p\\_i\\le 2\\times 10^{5})$。');
INSERT INTO `problem` VALUES ('2491104f-8fdf-43d0-b183-62938543abc0', '吴雨婷老师上课笔记', '# cMachine Learning<br><br>> 吴雨婷<br>><br>> ytwu1@bjtu.edu.cn<br><br>## 0. 课程<br><br>* 课程目标<br><br>* 主要内容<br>  * 有监督学习过渡到无监督学习<br><br>* 考核方式<br>  * 20%作业 + 30%实验 + 50%考试(半开卷)<br>  * 8次小作业<br>  * 半开卷: 能带一张A4纸<br><br>* 答疑<br>  * 周一下午 16:10-18:00<br>  * YF706<br><br>## 1. 绪论<br><br>### 1.1 背景<br><br>* 概念<br>  * 计算机利用经验改善系统自身性能的行动<br>  * 三个重要的理论问题<br>    * 一致: 样本集和测试集i.i.d<br>    * 划分: 在样本空间内寻找决策分界面<br>    * 泛化: 对未知样本的判断能力<br>    * i.i.d: 独立同分布<br><br>* 范围<br><br>* 应用<br><br>* 发展历史<br><br>* 知名人物<br>  * 深度学习三巨头<br><br>### 1.2 基本知识<br><br>* 机器学习的类型<br>  * 监督学习<br>  * 无监督学习<br>  * 强化学习<br><br>* 基本术语<br>  * (略)<br>  * **假设空间**<br>    * 定义：所有属性的可能性(可能取值)组成的空间<br>    * 每维属性还包含一个通配符，并且存在空集<br>    * 所以比如3个属性，每个属性有3种取值<br>    * 则 **总假设空间大小** 为 4\\*4\\*4 + 1 = 65<br>  * **版本空间**<br>    * 定义：多个与训练集一致的 **假设**<br>  * **归纳偏好**<br>    * 定义：学习过程中对某种类型假设的偏好<br>    * 每种算法必有其归纳偏好<br>    > \"奥卡姆剃刀\" 原则<br><br>* No Free Lunch: 每个算法都有其优势<br>  * 西瓜书的特例证明，假设 **所有问题出现的概率相同**，则得到对于二分类问题：**总误差和学习算法无关**<br>    * 但现实中，**问题出现概率并不同**，所以每个算法都有它的优势<br><br>* 统计学习 三要素<br>  * 模型<br>  * 策略<br>    * 损失函数 Loss Function<br>    * 风险函数 Risk Function<br>  * 算法<br><br>### 1.3 机器学习 开发流程<br><br>* 一般步骤<br>  * 数据收集<br>  * 数据清洗<br>  * 特征工程<br>  * 数据建模<br><br>### 1.4 模型的评估和选择<br><br>* 指标<br>  * Error Rate<br>  * Accuracy   = (TP + FN) / (TP + FN + FP + TN)<br>  * Precision  = TP / (TP + FP)<br>  * Recall     = TP / (TP + FN)<br>  * Loss<br><br>* 拟合问题<br>  * 过拟合<br>    * 解决方法：优化目标加正则项、early stop<br>  * 欠拟合<br><br>* 评估方法<br>  * 留出法<br>  * 交叉验证法<br>    * 如：10折交叉验证<br>  * 留一法<br>  * 自助法<br><br>* 性能度量<br>  * 回归任务<br>    * 最常用的是：均方误差<br>      * $ E(f;D) = \\Large \\frac{1}{m} \\sum_{i=1}^{m}(f(x_i)-y_i)^2 $<br>  * 分类任务<br>    * 最常用的是：ErrorRate，Accuracy<br>    * Precision 与 Recall 往往是矛盾的<br>  * **P-R 曲线**<br>    * 算出所有样本的正例概率，然后使用这些正例概率分别作为阈值，得到混淆矩阵<br>    * 将每个混淆矩阵转换为一个点对 (R, P)<br>    * 将这些点绘制在平面直角坐标系上，得到 P-R 曲线<br>    * 将曲线上 \"P=R\" 的点，称为 **平衡点(Break-event Point)**<br>    * **平衡点**，用于衡量P-R曲线有交叉的分类器性能高低<br>    * ![1](./Notes/23.9.11.1.png)<br>  * **F1度量** (F1-Score)<br>    * $ F1 = \\Large \\frac{2 \\times P \\times R}{P + R} \\normalsize = \\Large \\frac{2 \\times TP}{样例总数 + TP - TN} $<br>    * $ F_{\\beta} = Large \\frac{(1+\\beta^2)\\times P \\times R}{(\\beta^2 \\times P) + R} $<br>      * 当 $ \\beta = 1 $ 时，标准 $F_1$<br>      * 当 $ \\beta > 1 $ 时，偏重recall（如逃犯信息检索）<br>      * 当 $ \\beta < 1 $ 时，偏重precision（如商品推荐系统）<br>  * **macro-F1**<br>    * 当需要对多个混淆矩阵做性能度量时，可以使用 **macro-F1**<br>    * **macro-P**: $P_i$ 的均值<br>    * **macro-R**: $R_i$ 的均值<br>    * **macro-F1**: 通过 macro-P 和 macro-R 算出 macro-F1<br>    * 先取均值，再计算 $F1$<br>  * **micro-F1**<br>    * 先计算出 $F1_i$，再取均值<br>  * **ROC图**<br>    * 类似P-R曲线，先对样本排序，再将样本逐个作为阈值得到多个点<br>    * 纵轴: $ TPR = \\Large \\frac{TP}{TP+FN} $<br>      * $ FNR = 1 - TPR $<br>    * 横轴: $ FPR = \\Large \\frac{FP}{FP+TN} $<br>      * $ TNR = 1 - FPR $<br>    * 阈值从高到低时，设前一个点为(x, y)，则下一个点为 $ (x, y + \\frac{1}{m^+}) $ 或 $ (x + \\frac{1}{m^-}, y) $<br>      * 这个性质可以用于加速图像的绘制<br>    * AUC: Area Under Curve<br>      * 曲线下方面积，用于衡量样本预测的排序质量（正样本尽量靠前，负样本尽量靠后）<br>    * ![roc](./Notes/23.9.11.2.png)<br>    * 问题：为什么阈值要取样本的确切点呢？<br>      * 因为连续值没有意义，样本是离散的！<br>  * 代价敏感错误率<br>    * 设定“代价矩阵”，令 $cost_{ij}$ 表示将第 $i$ 类样本预测成 $j$ 的代价<br>    * 就是给错误率加权<br>    * $cost_{01}$：把正例预测成负例的代价<br>  * **代价曲线**<br>    * 横轴：取值为 [0, 1] 的正例概率代价<br>      * $ P(+)cost = \\Large \\frac{p*cost_{01}}{p*cost_{01} + (1-p)*cost_{10}} $<br>      * $p$：随机抽一个样本，正例概率（比例）<br>      * $p*cost_{01}$：正例预测错的期望花费<br>      * $p*cost_{01} + (1-p)*cost_{10}$：预测错的期望花费<br>    * 纵轴：取值为 [0, 1] 的归一化代价<br>      * $ cost_{norm} = \\Large \\frac{FNR * p * cost_{01} + FPR * (1-p) * cost_{10}}{p*cost_{01} + (1-p)*cost_{10}} $<br>      * 实际上，就是 $ 正例预测错的概率 * 正例概率代价 + 负例预测错的概率 * 负例概率代价 $<br>    * 如何绘制代价曲线<br>      * 设 ROC上的一个点为 (FPR, TPR)<br>      * 则 将该点转化为代价曲线上的一条线段<br>      * $ x = P(+)cost $<br>      * $ y = FNR * x + FPR * (1 - x) $<br>      * $y$ 显然是关于 $x$ 的一条直线，但 $x$ 有取值范围，所以这是一条线段<br>    * 取所有线段下方面积的交集，即为 **所以条件下，该学习器的期望总体代价**<br>      * 所有线段产生贡献的部分，称为 **代价曲线**<br>      * ![代价曲线](./Notes/23.9.11.3.png)<br>    * 作用<br>      * 可以或得到每种正例概率代价下，最优的阈值<br>  * 偏差 与 方差<br>    * 方差 Variance<br>    * 偏差 Bias<br>    * ![偏差和方差](./Notes/23.9.11.4.png)<br>    * 偏差：算法本身的拟合能力<br>    * 方差：数据扰动所造成的影响<br>    * 噪声：学习问题本身的难度（任务本身、数据集本身）<br>    * 期望泛化误差 $E(f;D) = E_D[(f(x;D)-\\bar{f}(x))^2] + (\\bar{f}(x)-y)^2+E_D[(y_D-y)^2]$<br>      * 即 $E(f;D)=bias^2(x)+var(x)+\\epsilon^2$<br>    * 偏差-方差窘境<br>      * 训练初期，拟合能力不强，偏差主导泛化错误率<br>      * 训练加深，拟合能力增强，方差主导泛化错误率<br>      * 训练充足，拟合能力非常强，若训练数据自身的、非全局的特性被学到，则会发生过拟合<br><br>***<br><br>## 2. 线性模型<br><br>### 2.1 线性回归<br><br>#### 2.1.1 线性回归<br><br>* 回归的概念<br>  * 回归：连续<br>  * 分类：离散<br>* 线性回归<br>  * 一种通过属性的 **线性组合** 来进行预测的 **线性模型**<br>  * 一般形式：$f(x) = w_1x_1+w_2x_2+...+w_dx_d+b$<br>  * 向量形式：$f(x)=w^Tx+b$<br>    * $x = (x_1;x_2;...;x_d)$<br>    * 若向量的划分符号为 $;$ 则表示列向量<br>  * 最小二乘法：基于均方误差最小化<br>    * 均方误差：$J(w, b) = \\sum_{i=1}^{m}(y^{(i)}-wx^{(i)}-b)^2$<br>    * 目标：$argmin_{(w,b)} \\ J(w, b)$<br>    * 机器学习凸函数定义：$f(x_1+x_2)  \\leq f(x_1) + f(x_2)$<br>    * 根据 $\\Large\\frac{\\partial J(w, b)}{b}\\normalsize = 0$，得到 $b = \\bar{y} - w \\bar{x}$<br>    * 根据 $\\Large \\frac {\\partial J(w, b)}{\\partial w} \\normalsize = 0$，得到 $w = \\Large \\frac{\\sum_{i=1}^{m} (x^{(i)}-\\bar{x})(y^{(i)}-\\bar{y}) }{ \\sum_{i=1}^{m}(x^{(i)}-\\bar{x})^2 }$<br>    * 【作业：证明最小二乘法】<br>  * 000000：基于残差平方和最小化<br>    * 残差平方和：$J(w) = \\frac{1}{2} \\sum_{i=1}^{m} (h(x^{(i)})-y^{(i)})^2$<br>* 度量误差<br>  * 损失函数 Loss Function：单样本预测的错误<br>  * 代价函数 Cost Function：全部样本集的平均误差<br>  * 目标函数 Object Function：最终需要优化的函数<br>* 广义线性模型<br>  * 一般形式：$y=g^{-1}(w^Tx+b)$<br>  * 当 $g(·)=ln(·)$ 时，为对数线性回归<br><br>#### 2.1.2 梯度下降<br><br>* 梯度下降的三种形式<br>  * 批量梯度下降（Batch Gradient Descent, BGD）<br>    * 梯度下降的每一步，都用到了 **所有** 的训练样本<br>    * $w_j := w_j - \\alpha \\frac{1}{m} \\sum_{i=1}^{m} ((h(x^{(i)})-y^{(i)})· x_j^{(i)})$<br>    * $\\sum$ 内部的项，即为 **梯度**，即 $\\Large\\frac{\\partial \\ J(w)}{\\partial \\ w_j}$<br>    * 优点：考虑所有样本；缺点：太慢<br>  * 随机梯度下降（Stochastic Gradient Descent, SGD）<br>    * 梯度下降的每一步，随机一个样本训练<br>    * $w_j := w_j - \\alpha \\Large \\frac{\\partial \\ J(w)}{\\partial \\ w_j}$<br>  * 小批量梯度下降（Mini-Batch Gradient Descent, MBGD）<br>    * 梯度下降的每一步，用到了 **一定批量** 的训练样本<br><br>* 梯度下降 和 最小二乘法<br>  * 梯度下降 需要超参 **学习率$\\alpha$**<br>  * 最小二乘法，需要矩阵求逆<br><br>* 数据归一化/标准化<br>  * 归一化<br>    * $x^* = \\Large \\frac {x - x_{min}} {x_{max} - x_{min}}$<br>  * Z-Score标准化<br>    * $x^* = \\Large \\frac  {x - \\mu} {\\sigma} $<br><br>* 过拟合/欠拟合<br><br>### 2.1.3 正则化<br><br>* 正则化值，可以用于衡量模型复杂度<br>  * 模型越复杂，正则化值越高<br>  * 正则化项是一个项，会加在代价函数的最后面<br>  <br>* L1正则化，Lasso回归<br>  * 更容易使得模型的权重变为0（换句话说，可以用于特征选择）<br><br>* L2正则化，岭回归<br>  * 相比L1，更加平滑，容易使得模型的权重趋近0<br><br>*【公司面试常考的，L1正则和L2正则的区别，区别产生的原因】<br><br>* Elastic Net，弹性网络<br>  * L1和L2的均值<br><br>### 2.1.4 回归的评价指标<br><br>* 均方误差 MSE<br>  * 缺点：存在平方；量纲不同<br><br>* 均方根误差 RMSE<br>  * 缺点：存在平方（所以容易受到一些属性特大误差的影响）<br><br>* 平均绝对误差 MAE<br>  * 缺点：不能求导<br><br>* R方 R2Score<br>  * $ R^2(y,\\hat{r}) = 1 - \\Large \\frac {MSE} {Var} $<br>  * 越接近1，说明模型拟合得越好<br><br>### 2.2 逻辑回归<br><br>#### 2.2.1 & 2.2.2 分类问题 & 逻辑回归概述<br><br>* 二分类、多分类<br>* 如何将回归问题转换为分类问题？<br>  * 分类器<br>  * 单位阶跃函数：不可导<br>  * 对数几率函数 Sigmoid：$\\sigma(z) = \\Large \\frac {1} {1 + e^{-z}} $<br>  * 二分类的损失函数，我们通常这么定义<br>    * $ J(\\theta) = \\Large \\frac{1}{m} \\normalsize \\sum_{i=1}^{m} Cost(h_{\\theta}(x^i, y^i)) $<br>    * $ Cost(h_{\\theta} (x^i, y^i)) = -log(h_{\\theta}(x))[y==1] + -log(1-h_{\\theta}(x))[y==0]$<br>    * 得到逻辑回归的假设函数（即损失函数）<br>      * $L(\\hat{y}, y) = -ylog(\\hat{y})-(1-y)log(1-\\hat{y})$<br>* 几率（事件发生比）<br>  * 定义：$\\Large \\frac{p}{1-p}$<br><br>* 对数几率<br>  * 定义：$log \\Large \\frac{p}{1-p} \\normalsize = w^T x + b = z$<br>  * 求解得到对数几率函数：$g(z) = p = \\Large \\frac{1}{1+e^{-z}}$<br>  * 导数：$g\'(z) = g(z)(1-g(z))$<br>  * 【回去推一下】<br><br>* 逻辑回归模型的假设是：<br><br>#### 2.2.3 逻辑回归求解<br><br>* 似然函数是已知事件的结果，求参数<br>  * $P(y|\\theta)$：若已知 $\\theta$，求 $y$ 发生的概率，这是概率<br>  * 如果已知 $y$，求一个最合适的 $\\theta$，求最可能发生 $y$，这是似然函数<br>* 似然函数<br>  * $L(w) = \\Pi_{i=1}^{m} P(y^{(i)}|x^{(i)}; w)$<br>  * 因为梯度下降还是需要求导，所以对上式取对数，将连乘化简为连加<br>  * 得到代价函数 $J(w) = -1/m\\  logL(w)$<br>* 【可不可以把学习的过程，理解成最大化似然函数的过程】<br><br>### 2.3 线性判别分析<br><br>* 线性判别分析（Linear DiscriminantAnalysis LDA）<br>* 核心思想<br>  * 同类点投影点尽可能近，协方差尽可能小<br>  * 异类点投影点尽可能远，中心之间距离尽可能大<br>* 一些定义<br>  * $X_I$：第i类样本的集合<br>  * $\\mu_i$：第i类样本的均值向量<br>  * $\\Sigma_i = \\Sigma_{x\\in X_i}(x-\\mu_i)(x-\\mu_i)^T$：第i类样本的协方差矩阵<br>  * $w^T\\mu_0$：两类样本的中心在直线上的投影（内积）<br>  * $w^T\\Sigma_0w$：两类样本投影点的协方差<br>  * etc.<br>* 拉格朗日乘子法<br>  * 若需要最小化 $-w^TS_bw + \\lambda(w^T S_w w - 1)$<br>    * 对函数求偏导<br>    * 得到 $S_b w = \\lambda S_w w$<br>    * 此时，$S_b$ 和 $(\\mu_0-\\mu_1)$ 是 **同向向量**<br>      * 拆开，发现后面两个矩阵的结果是标量<br><br>* LDA的贝叶斯决策论解释<br>  * 若两类数据同先验、满足高斯分布且协方差相等时<br>  * 则LDA达到最优分类<br><br>* LDA推广——多分类任务<br>  * 全局散度矩阵、类内散度矩阵、类间散度矩阵<br>  * ![image-20230920153733616](./Notes/image-20230920153733616.png)<br>  * $tr(A)$：trace，矩阵的迹<br>    * 矩阵对角线元素相加<br><br>* LDA的另外一个作用：监督降维<br>* 算法流程<br>  * 略<br><br><br>### 2.4 多分类学习<br><br>* 多分类学习方法<br>  * 二分类推广到多分类<br>  * 利用二分类学习器解决多分类**（常用）**<br>    * 对问题进行拆分<br>* 拆分策略<br>  * 一对一：拆分成 $C(n, 2)$，然后取最多<br>  * 一对其余：拆分成 $n$ 个，然后 $1$ 正例 $n-1$ 反例<br>  * 多对多<br>    * 若干类为正类，若干类为反类，每次输出一些纠错输出码（ECOC）<br>    * 二类：正类 + 反类<br>    * 三类：正类 + 反类 + 停用类<br>    * ![image-20230920155349835](./Notes/image-20230920155349835.png)<br><br>### 2.5 类别不平衡<br><br>#### 2.5.1 概述<br><br>* 真样本数过少（比如系外行星宜居度预测）<br><br>#### 2.5.2 困难点<br><br>#### 2.5.3 解决方法<br><br>* 将二分类正反例阈值调整为 $\\Large \\frac{p}{1-p}$<br>* 这就是类别不平衡学习的一个基本策略——**再缩放(Rescaling)**<br>  * 欠采样：去除一些负例，使得正反例数目接近<br>  * 过采样：增加一些正例，使得正反例数目接近<br>  * 阈值移动<br><br>### 2.6 优化提要<br><br>* 各个模型的优化目标<br>  * 最小二乘法：最小化均方误差<br>  * 逻辑回归：<br>', '');
INSERT INTO `problem` VALUES ('5eb01691-b618-4921-b377-05fddca08205', '操作系统实验3：批处理与特权级', '本实验的主要目的是实现一个简单的批处理操作系统并理解特权级的概念。<br><br>1. 设计和实现应用程序<br><br>实现一个简单的批处理操作系统，需要先实现应用程序，要求应用程序在用户态下运行。应用程序及其对应的库文件放置在工作目录下的user目录下。这部分的实现与上一节裸机环境和最小化内核部分有很多相同的实现。<br><br>注意，通过如下命令创建user目录：<br><br>cargo new user_lib<br>mv user_lib user<br>rm user/src/main.rs<br><br>（1）首先实现应用程序与系统约定的两个系统调用sys_write和sys_exit<br><br>具体代码在user/src/syscall.rs中，具体内容如下：<br><br>use core::arch::asm;<br><br>const SYSCALL_WRITE: usize = 64;<br>const SYSCALL_EXIT: usize = 93;<br><br>fn syscall(id: usize, args: [usize; 3]) -> isize {<br>    let mut ret: isize;<br>    unsafe {<br>        asm!(\"ecall\",<br>             in(\"x10\") args[0],<br>             in(\"x11\") args[1],<br>             in(\"x12\") args[2],<br>             in(\"x17\") id,<br>             lateout(\"x10\") ret<br>        );<br>    }<br>    ret<br>}<br><br>pub fn sys_write(fd: usize, buffer: &[u8]) -> isize {<br>    syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()])<br>}<br><br>pub fn sys_exit(exit_code: i32) -> isize {<br>    syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0])<br>}<br><br>同时，还需要在lib.rs实现进一步的封装。<br>在user/src/lib.rs中增加如下内容：<br><br>#![no_std]<br><br>use syscall::*;<br><br>pub fn write(fd: usize, buf: &[u8]) -> isize { sys_write(fd, buf) }<br>pub fn exit(exit_code: i32) -> isize { sys_exit(exit_code) }<br><br><br>（2）实现格式化输出<br><br>为了实现格式化输出，我们还需要把 Stdout::write_str 改成基于 write 的实现，且传入的 fd 参数设置为 1，它代表标准输出， 也就是输出到屏幕。<br>具体代码在user/src/console.rs中，具体内容如下：<br> <br>use core::fmt::{self, Write};<br>use super::write;<br><br>const STDOUT: usize = 1;<br><br>struct Stdout;<br><br>impl Write for Stdout {<br>    fn write_str(&mut self, s: &str) -> fmt::Result {<br>        write(STDOUT, s.as_bytes());<br>        Ok(())<br>    }<br>}<br><br>pub fn print(args: fmt::Arguments) {<br>    Stdout.write_fmt(args).unwrap();<br>}<br><br>#[macro_export]<br>macro_rules! print {<br>    ($fmt: literal $(, $($arg: tt)+)?) => {<br>        $crate::console::print(format_args!($fmt $(, $($arg)+)?));<br>    }<br>}<br><br>#[macro_export]<br>macro_rules! println {<br>    ($fmt: literal $(, $($arg: tt)+)?) => {<br>        $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?));<br>    }<br>}<br><br>（3）实现语义支持<br><br>此外，还需要实现对panic的处理。具体代码在user/src/lang_items.rs。<br><br>use core::panic::PanicInfo;<br><br>#[panic_handler]<br>fn panic_handler(panic_info: &PanicInfo) -> ! {<br>    if let Some(location) = panic_info.location() {<br>        println!(<br>            \"Panicked at {}:{}, {}\", <br>            location.file(), <br>            location.line(), <br>            panic_info.message().unwrap());<br>    } else {<br>        println!(\"Panicked: {}\", panic_info.message().unwrap());<br>    }<br>    loop {}<br>}<br><br><br>（4）应用程序内存布局<br><br>我们还需要将应用程序的起始物理地址调整为 0x80400000，这样应用程序都会被加载到这个物理地址上运行，从而进入用户库的入口点，并会在初始化之后跳转到应用程序主逻辑。实现方式类似前一节的linker.ld。<br><br>具体代码在user/src/linker.ld，具体内容如下：<br><br>OUTPUT_ARCH(riscv)<br>ENTRY(_start)<br><br>BASE_ADDRESS = 0x80400000;<br><br>SECTIONS<br>{<br>    . = BASE_ADDRESS;<br>    .text : {<br>        *(.text.entry)<br>        *(.text .text.*)<br>    }<br>    .rodata : {<br>        *(.rodata .rodata.*)<br>        *(.srodata .srodata.*)<br>    }<br>    .data : {<br>        *(.data .data.*)<br>        *(.sdata .sdata.*)<br>    }<br>    .bss : {<br>        start_bss = .;<br>        *(.bss .bss.*)<br>        *(.sbss .sbss.*)<br>        end_bss = .;<br>    }<br>    /DISCARD/ : {<br>        *(.eh_frame)<br>        *(.debug*)<br>    }<br>}<br><br>同时，注意增加配置文件使用linker.ld文件，user/.cargo/config配置文件的内容如下：<br>[build]<br>target = \"riscv64gc-unknown-none-elf\"<br><br>[target.riscv64gc-unknown-none-elf]<br>rustflags = [<br>    \"-Clink-args=-Tsrc/linker.ld\",<br>]<br><br><br>（5）最终形成运行时库lib.rs<br><br>定义用户库的入口点 _start，_start这段代码编译后会存放在.text.entry代码段中，这在前面内存布局中已经定义了。此外，通过#[linkage = \"weak\"]确保lib.rs和bin下同时存在main的编译能够通过。在lib.rs增加的代码如下：<br>注意：最开始的两行代码需要放在 #![no_std]的下面，放在后面会出现错误。<br><br>#![feature(linkage)]<br>#![feature(panic_info_message)]<br><br>#[macro_use]<br>pub mod console;<br>mod syscall;<br>mod lang_items;<br><br>fn clear_bss() {<br>    extern \"C\" {<br>        fn start_bss();<br>        fn end_bss();<br>    }<br>    (start_bss as usize..end_bss as usize).for_each(|addr| {<br>        unsafe { (addr as *mut u8).write_volatile(0); }<br>    });<br>}<br><br>#[no_mangle]<br>#[link_section = \".text.entry\"]<br>pub extern \"C\" fn _start() -> ! {<br>    clear_bss();<br>    exit(main());<br>    panic!(\"unreachable after sys_exit!\");<br>}<br><br>#[linkage = \"weak\"]<br>#[no_mangle]<br>fn main() -> i32 {<br>    panic!(\"Cannot find main!\");<br>}<br><br>（6）应用程序模板<br><br>应用程序都存放在usr/src/bin下，模板如下。这段模板代码引入了外部库，就是lib.rs定义以及它所引用的子模块。<br>注意：下面的模板代码不需创建，只是作为后续创建应用程序的参考。<br><br>#![no_std]<br>#![no_main]<br><br>#[macro_use]<br>extern crate user_lib;<br><br>#[no_mangle]<br>fn main() -> i32 {<br>    0<br>}<br><br>（7）实现多个不同的应用程序<br><br>基于上述模板，我们可以在bin下实现多个不同的应用程序。<br>其中user/src/bin/00hello_world.rs内容具体如下：<br><br>#![no_std]<br>#![no_main]<br><br>use core::arch::asm;<br><br>#[macro_use]<br>extern crate user_lib;<br><br>#[no_mangle]<br>fn main() -> i32 {<br>    println!(\"Hello, world!\");<br>    unsafe {<br>        asm!(\"sret\");<br>    }<br>    0<br>}<br><br>/user/src/bin/01store_fault.rs内容具体如下：<br><br>#![no_std]<br>#![no_main]<br>#[macro_use]<br>extern crate user_lib;<br>#[no_mangle]<br>fn main() -> i32 {<br>    println!(\"Into Test store_fault, we will insert an invalid store operation...\");<br>    println!(\"Kernel should kill this application!\");<br>    unsafe { (0x0 as *mut u8).write_volatile(0); }<br>    0<br>}<br><br>/user/src/bin/02power.rs内容具体如下：<br>#![no_std]<br>#![no_main]<br>#[macro_use]<br>extern crate user_lib;<br>const SIZE: usize = 10;<br>const P: u32 = 3;<br>const STEP: usize = 100000;<br>const MOD: u32 = 10007;<br>#[no_mangle]<br>fn main() -> i32 {<br>    let mut pow = [0u32; SIZE];<br>    let mut index: usize = 0;<br>    pow[index] = 1;<br>    for i in 1..=STEP {<br>        let last = pow[index];<br>        index = (index + 1) % SIZE;<br>        pow[index] = last * P % MOD;<br>        if i % 10000 == 0 {<br>            println!(\"{}^{}={}\", P, i, pow[index]);<br>        }<br>    }<br>    println!(\"Test power OK!\");<br>    0<br>}<br><br>（8）编译生成应用程序二进制码<br><br>编写Makefile文件，user/Makefile内容如下：<br><br>TARGET := riscv64gc-unknown-none-elf<br>MODE := release<br>APP_DIR := src/bin<br>TARGET_DIR := target/$(TARGET)/$(MODE)<br>APPS := $(wildcard $(APP_DIR)/*.rs)<br>ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS))<br>BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS))<br><br>OBJDUMP := rust-objdump --arch-name=riscv64<br>OBJCOPY := rust-objcopy --binary-architecture=riscv64<br><br>elf:<br>	@cargo build --release<br>	@echo $(APPS)<br>	@echo $(ELFS)<br>	@echo $(BINS)<br><br>binary: elf<br>	$(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));)<br><br>build: binary<br><br>执行make build进行编译。<br><br>编译完成后，我们可以利用qemu-riscv64模拟器执行编译生成的程序。需要注意的是，特权指令在这里是无法直接执行的。至此，应用程序设计实现完成。<br><br><br><br>2. 链接应用程序到内核<br><br>为了将编译生成的应用程序二进制码动态链接到内容中，我们需要编写一个编译脚本os/build.rs以生成专门用于链接的脚本文件link_app.S。注意是该汇编脚本直接放在项目文件夹 os 中，而不是源码文件夹 src。当执行cargo build命令时就会执行build.rs脚本。<br><br>os/build.rs文件的内容具体如下：<br><br>use std::io::{Result, Write};<br>use std::fs::{File, read_dir};<br><br>fn main() {<br>    println!(\"cargo:rerun-if-changed=../user/src/\");<br>    println!(\"cargo:rerun-if-changed={}\", TARGET_PATH);<br>    insert_app_data().unwrap();<br>}<br><br>static TARGET_PATH: &str = \"../user/target/riscv64gc-unknown-none-elf/release/\";<br><br>fn insert_app_data() -> Result<()> {<br>    let mut f = File::create(\"src/link_app.S\").unwrap();<br>    let mut apps: Vec<_> = read_dir(\"../user/src/bin\")<br>        .unwrap()<br>        .into_iter()<br>        .map(|dir_entry| {<br>            let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap();<br>            name_with_ext.drain(name_with_ext.find(\'.\').unwrap()..name_with_ext.len());<br>            name_with_ext<br>        })<br>        .collect();<br>    apps.sort();<br><br>    writeln!(f, r#\"<br>    .align 3<br>    .section .data<br>    .global _num_app<br>_num_app:<br>    .quad {}\"#, apps.len())?;<br><br>    for i in 0..apps.len() {<br>        writeln!(f, r#\"    .quad app_{}_start\"#, i)?;<br>    }<br>    writeln!(f, r#\"    .quad app_{}_end\"#, apps.len() - 1)?;<br><br>    for (idx, app) in apps.iter().enumerate() {<br>        println!(\"app_{}: {}\", idx, app);<br>        writeln!(f, r#\"<br>    .section .data<br>    .global app_{0}_start<br>    .global app_{0}_end<br>app_{0}_start:<br>    .incbin \"{2}{1}.bin\"<br>app_{0}_end:\"#, idx, app, TARGET_PATH)?;<br>    }<br>    Ok(())<br>}<br><br><br>3. 找到并加载应用程序二进制码<br><br>为了实现批处理操作系统，我们在os目录下实现一个batch子模块。其主要功能是保存应用程序的数据及对应的位置信息，以及当前执行到第几个应用程序。同时，也会初始化应用程序所需的内存并加载执行应用程序。<br><br>os/src/batch.rs的内容如下：<br><br>use core::arch::asm;<br>use core::cell::RefCell;<br>use lazy_static::*;<br><br>const MAX_APP_NUM: usize = 16;<br>const APP_BASE_ADDRESS: usize = 0x80400000;<br>const APP_SIZE_LIMIT: usize = 0x20000;<br><br>struct AppManager {<br>    inner: RefCell<AppManagerInner>,<br>}<br><br>struct AppManagerInner {<br>    num_app: usize,<br>    current_app: usize,<br>    app_start: [usize; MAX_APP_NUM + 1],<br>}<br><br>unsafe impl Sync for AppManager {}<br><br>impl AppManagerInner {<br>    pub fn print_app_info(&self) {<br>        println!(\"[kernel] num_app = {}\", self.num_app);<br>        for i in 0..self.num_app {<br>            println!(\"[kernel] app_{} [{:#x}, {:#x})\", i, self.app_start[i], self.app_start[i + 1]);<br>        }<br>    }<br><br>    unsafe fn load_app(&self, app_id: usize) {<br>        if app_id >= self.num_app {<br>            panic!(\"All applications completed!\");<br>        }<br><br>        println!(\"[kernel] Loading app_{}\", app_id);<br>        // clear icache<br>        asm!(\"fence.i\");<br>        // clear app area<br>        (APP_BASE_ADDRESS..APP_BASE_ADDRESS + APP_SIZE_LIMIT).for_each(|addr| {<br>            (addr as *mut u8).write_volatile(0);<br>        });<br>        let app_src = core::slice::from_raw_parts(<br>            self.app_start[app_id] as *const u8,<br>            self.app_start[app_id + 1] - self.app_start[app_id]<br>        );<br>        let app_dst = core::slice::from_raw_parts_mut(<br>            APP_BASE_ADDRESS as *mut u8,<br>            app_src.len()<br>        );<br>        app_dst.copy_from_slice(app_src);<br>    }<br><br>    pub fn get_current_app(&self) -> usize { self.current_app }<br><br>    pub fn move_to_next_app(&mut self) {<br>        self.current_app += 1;<br>    }<br>}<br><br>lazy_static! {<br>    static ref APP_MANAGER: AppManager = AppManager {<br>        inner: RefCell::new({<br>            extern \"C\" { fn _num_app(); }<br>            let num_app_ptr = _num_app as usize as *const usize;<br>            let num_app = unsafe { num_app_ptr.read_volatile() };<br>            let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1];<br>            let app_start_raw: &[usize] = unsafe {<br>                core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1)<br>            };<br>            app_start[..=num_app].copy_from_slice(app_start_raw);<br>            AppManagerInner {<br>                num_app,<br>                current_app: 0,<br>                app_start,<br>            }<br>        }),<br>    };<br>}<br><br>pub fn init() {<br>    print_app_info();<br>}<br><br>pub fn print_app_info() {<br>    APP_MANAGER.inner.borrow().print_app_info();<br>}<br><br>pub fn run_next_app() -> ! {<br>    let current_app = APP_MANAGER.inner.borrow().get_current_app();<br>    unsafe {<br>        APP_MANAGER.inner.borrow().load_app(current_app);<br>    }<br><br>    APP_MANAGER.inner.borrow_mut().move_to_next_app();<br>    extern \"C\" { fn __restore(cx_addr: usize); }<br>    unsafe {<br>        __restore(KERNEL_STACK.push_context(<br>            TrapContext::app_init_context(APP_BASE_ADDRESS, USER_STACK.get_sp())<br>        ) as *const _ as usize);<br>    }<br>    panic!(\"Unreachable in batch::run_current_app!\");<br>}<br><br>因为使用了外部库 lazy_static 提供的 lazy_static! 宏，因此需要在Cargo.toml中加入依赖。lazy_static!宏提供了全局变量的运行时初始化功能，我们借助lazy_static!声明了一个 AppManager结构的全局实例APP_MANAGER，使得只有在第一次使用它时才会进行实际的初始化工作。<br><br>修改os/Cargo.toml配置文件，在[dependencies]下增加如下内容：<br>lazy_static = { version = \"1.4.0\", features = [\"spin_no_std\"] }<br><br><br><br><br>4. 实现用户栈和内核栈<br><br>为了实现特权级的切换，还需要实现用户栈和内核栈。在batch.rs中增加如下实现。需要注意在RISC-V中栈是向下增长的。<br><br>use crate::trap::TrapContext;<br><br>const USER_STACK_SIZE: usize = 4096 * 2;<br>const KERNEL_STACK_SIZE: usize = 4096 * 2;<br><br>#[repr(align(4096))]<br>struct KernelStack {<br>    data: [u8; KERNEL_STACK_SIZE],<br>}<br><br>#[repr(align(4096))]<br>struct UserStack {<br>    data: [u8; USER_STACK_SIZE],<br>}<br><br>static KERNEL_STACK: KernelStack = KernelStack { data: [0; KERNEL_STACK_SIZE] };<br>static USER_STACK: UserStack = UserStack { data: [0; USER_STACK_SIZE] };<br><br>impl KernelStack {<br>    fn get_sp(&self) -> usize {<br>        self.data.as_ptr() as usize + KERNEL_STACK_SIZE<br>    }<br>    pub fn push_context(&self, cx: TrapContext) -> &\'static mut TrapContext {<br>        let cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext;<br>        unsafe { *cx_ptr = cx; }<br>        unsafe { cx_ptr.as_mut().unwrap() }<br>    }<br>}<br><br>impl UserStack {<br>    fn get_sp(&self) -> usize {<br>        self.data.as_ptr() as usize + USER_STACK_SIZE<br>    }<br>}<br><br><br>其中，TrapContext是在trap中定义的。<br><br>// os/src/trap/context.rs<br><br>#[repr(C)]<br>pub struct TrapContext {<br>    pub x: [usize; 32],<br>    pub sstatus: Sstatus,<br>    pub sepc: usize,<br>}<br><br><br>5. 实现trap管理<br><br>特权级切换的主要内容就是实现对trap的管理。其主要内容就是当应用程序通过ecall进入到内核状态时，要保存被中断的应用程序的上下文。同时，还要根据CSR寄存器内容完成系统调用的分发与处理。在完成系统调用后，还需要恢复被中断的应用程序的上下文，并通 sret 让应用程序继续执行。<br><br>Trap处理的流程大致如下：首先通过将 Trap上下文保存在内核栈上，然后跳转到trap处理函数完成 Trap 分发及处理。当处理函数返回之后，再从保存在内核栈上的Trap上下文恢复寄存器。最后通过一条 sret 指令回到应用程序继续执行。<br><br>（1）Trap 上下文的保存与恢复<br><br>首先，修改stvec寄存器来指向正确的 Trap 处理入口点。<br><br>实现在os/src/trap/mod.rs文件中。具体内容如下：<br><br>use core::arch::global_asm;<br><br>global_asm!(include_str!(\"trap.S\"));<br><br>pub fn init() {<br>    extern \"C\" { fn __alltraps(); }<br>    unsafe {<br>        stvec::write(__alltraps as usize, TrapMode::Direct);<br>    }<br>}<br><br>这里我们引入了外部符号__alltraps来将Trap上线文保存在内核栈上。从上面的代码可以看出 __alltraps 的实现在os/src/trap/trap.S中，具体内容如下：<br><br># os/src/trap/trap.S<br><br>.altmacro<br><br>.macro SAVE_GP n<br>    sd x\\n, \\n*8(sp)<br>.endm<br><br><br>    .section .text<br>    .globl __alltraps<br>    .globl __restore<br>    .align 2<br>    <br>__alltraps:<br>    csrrw sp, sscratch, sp<br>    # now sp->kernel stack, sscratch->user stack<br>    # allocate a TrapContext on kernel stack<br>    addi sp, sp, -34*8<br>    # save general-purpose registers<br>    sd x1, 1*8(sp)<br>    # skip sp(x2), we will save it later<br>    sd x3, 3*8(sp)<br>    # skip tp(x4), application does not use it<br>    # save x5~x31<br>    .set n, 5<br>    .rept 27<br>        SAVE_GP %n<br>        .set n, n+1<br>    .endr<br>    # we can use t0/t1/t2 freely, because they were saved on kernel stack<br>    csrr t0, sstatus<br>    csrr t1, sepc<br>    sd t0, 32*8(sp)<br>    sd t1, 33*8(sp)<br>    # read user stack from sscratch and save it on the kernel stack<br>    csrr t2, sscratch<br>    sd t2, 2*8(sp)<br>    # set input argument of trap_handler(cx: &mut TrapContext)<br>    mv a0, sp<br>    call trap_handler<br><br>当Trap处理函数返回之后，还需要从栈上的Trap 上下文恢复的。我们通过 __restore来实现。<br><br># os/src/trap/trap.S<br><br>.macro LOAD_GP n<br>    ld x\\n, \\n*8(sp)<br>.endm<br><br>__restore:<br>    # case1: start running app by __restore<br>    # case2: back to U after handling trap<br>    mv sp, a0<br>    # now sp->kernel stack(after allocated), sscratch->user stack<br>    # restore sstatus/sepc<br>    ld t0, 32*8(sp)<br>    ld t1, 33*8(sp)<br>    ld t2, 2*8(sp)<br>    csrw sstatus, t0<br>    csrw sepc, t1<br>    csrw sscratch, t2<br>    # restore general-purpuse registers except sp/tp<br>    ld x1, 1*8(sp)<br>    ld x3, 3*8(sp)<br>    .set n, 5<br>    .rept 27<br>        LOAD_GP %n<br>        .set n, n+1<br>    .endr<br>    # release TrapContext on kernel stack<br>    addi sp, sp, 34*8<br>    # now sp->kernel stack, sscratch->user stack<br>    csrrw sp, sscratch, sp<br>    sret<br><br>（2）Trap 分发与处理<br><br>我们通过实现trap_handler 函数完成Trap的分发和处理。<br><br>// os/src/trap/mod.rs<br><br>mod context;<br><br>use riscv::register::{<br>    mtvec::TrapMode,<br>    stvec,<br>    scause::{<br>        self,<br>        Trap,<br>        Exception,<br>    },<br>    stval,<br>};<br><br>use crate::syscall::syscall;<br>use crate::batch::run_next_app;<br><br>#[no_mangle]<br>pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext {<br>    let scause = scause::read();<br>    let stval = stval::read();<br>    match scause.cause() {<br>        Trap::Exception(Exception::UserEnvCall) => {<br>            cx.sepc += 4;<br>            cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize;<br>        }<br>        Trap::Exception(Exception::StoreFault) |<br>        Trap::Exception(Exception::StorePageFault) => {<br>            println!(\"[kernel] PageFault in application, core dumped.\");<br>            run_next_app();<br>        }<br>        Trap::Exception(Exception::IllegalInstruction) => {<br>            println!(\"[kernel] IllegalInstruction in application, core dumped.\");<br>            run_next_app();<br>        }<br>        _ => {<br>            panic!(\"Unsupported trap {:?}, stval = {:#x}!\", scause.cause(), stval);<br>        }<br>    }<br>    cx<br>}<br><br>pub use context::TrapContext;<br><br>因为引入了riscv库，所以需要修改配置文件Cargo.toml，在[dependencies]下增加如下内容：<br>riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] }<br><br>（3）系统调用处理<br><br>为了实现对系统调用的处理，我们还需要实现syscall模块。syscall函数并不真正的处理系统调用，而是根据syscall ID分发到具体的处理函数进行处理。具体实现如下：<br><br>//os/src/syscall/mod.rs<br><br>const SYSCALL_WRITE: usize = 64;<br>const SYSCALL_EXIT: usize = 93;<br><br>mod fs;<br>mod process;<br><br>use fs::*;<br>use process::*;<br><br>pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize {<br>    match syscall_id {<br>        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),<br>        SYSCALL_EXIT => sys_exit(args[0] as i32),<br>        _ => panic!(\"Unsupported syscall_id: {}\", syscall_id),<br>    }<br>}<br><br>// os/src/syscall/fs.rs<br><br>const FD_STDOUT: usize = 1;<br><br>pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize {<br>    match fd {<br>        FD_STDOUT => {<br>            let slice = unsafe { core::slice::from_raw_parts(buf, len) };<br>            let str = core::str::from_utf8(slice).unwrap();<br>            print!(\"{}\", str);<br>            len as isize<br>        },<br>        _ => {<br>            panic!(\"Unsupported fd in sys_write!\");<br>        }<br>    }<br>}<br><br><br>// os/src/syscall/process.rs<br><br>use crate::batch::run_next_app;<br><br>pub fn sys_exit(exit_code: i32) -> ! {<br>    println!(\"[kernel] Application exited with code {}\", exit_code);<br>    run_next_app()<br>}<br><br><br>6. 执行应用程序<br><br>在执行应用程序之前，需要跳转到应用程序入口0x80400000，切换到用户栈，设置sscratch指向内核栈，并且用S特权级切换到U特权级。我们可以通过复用__restore的代码来实现这些操作。这样的话，只需要在内核栈上压入一个启动应用程序而特殊构造的Trap上线文，再通过__restore函数就可以实现寄存在为启动应用程序所需的上下文状态。<br><br>为此，我们为TrapContext实现app_init_context。具体代码如下：<br><br>// os/src/trap/context.rs<br>use riscv::register::sstatus::{Sstatus, self, SPP};<br><br>impl TrapContext {<br>    pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; }<br>    pub fn app_init_context(entry: usize, sp: usize) -> Self {<br>        let mut sstatus = sstatus::read();<br>        sstatus.set_spp(SPP::User);<br>        let mut cx = Self {<br>            x: [0; 32],<br>            sstatus,<br>            sepc: entry,<br>        };<br>        cx.set_sp(sp);<br>        cx<br>    }<br>}<br><br>同时，在batch.rs的run_next_app中我们可以看到调用了__restore在内核栈上压入了一个Trap上下文。<br><br><br><br>7. 修改main.rs<br><br>最后，修改main.rs增加新实现的模块，并且调用batch子模块进行初始化并批量执行应用程序。<br><br>#![no_std]<br>#![no_main]<br>#![feature(panic_info_message)]<br><br>#[macro_use]<br>mod console;<br>mod lang_items;<br>mod sbi;<br>mod syscall;<br>mod trap;<br>mod batch;<br><br>use core::arch::global_asm;<br><br>global_asm!(include_str!(\"entry.asm\"));<br>global_asm!(include_str!(\"link_app.S\"));<br><br>fn clear_bss() {<br>    extern \"C\" {<br>        fn sbss();<br>        fn ebss();<br>    }<br>    (sbss as usize..ebss as usize).for_each(|a| unsafe { (a as *mut u8).write_volatile(0) });<br>}<br><br>#[no_mangle]<br>pub fn rust_main() -> ! {<br>    clear_bss();<br>    println!(\"[Kernel] Hello, world!\");<br>    trap::init();<br>    batch::init();<br>    batch::run_next_app();<br>}<br><br>至此，批处理操作系统的实现完成。运行操作系统，查看系统运行结果是否正确。<br><br>8. 思考并回答问题<br>（1）分析应用程序的实现过程，并实现一个自己的应用程序；<br>（2）分析应用程序的链接、加载和执行过程；<br>（3）分析Trap是如何实现的？', '# 操作系统 实验3<br><br>> 21301114 俞贤皓<br>><br>> 环境（实验0~2）：Arch Linux 6.5.3-arch1-1<br>><br>> 环境（实验3）：Ubuntu 22.04.3 LTS (WSL)<br><br>## 1. 实验步骤<br><br>### 1.0 备注<br><br>* 我在上节课中，使用了0.2.0-alpha.2版本的rustsbi-qemu完成了实验，所以之后的实验我也均用最新版的rustsbi-qemu完成。<br>  * 我会把我遇到与新版rustsbi-qemu有关的问题 **加粗**<br>* 因为单双周记错了，所以实验课没带笔记本。前端时间正好给宿舍台式机配置了frp内网穿透，实现了ssh访问windows下的wsl。故今天尝试通过安卓的termux使用ssh，连接宿舍台式机的wsl，完成操作系统实验。<br>  * 所以本次实验的终端界面和前几次实验的终端界面不同<br>* 首先，要在wsl中配置实验环境<br>  * 安装Docker、载入镜像、生成容器、执行实验1开头的4句补充命令、`make && make run`。<br>  * ![img](./README/9397CEC692F66068E71D6E8C430C2C4B.jpg)<br>  * 环境配置完毕<br><br>### 1.1 设计和实现应用程序<br><br>* 创建应用程序<br>  * 这里先 `cargo new user_lib` 再 `mv user_lib user` ，是为了使 `user/Cargo.toml` 中的项目名称是 `user_lib`<br>  * ![img](./README/541F184F07F33D5A9758517A8FA96BCD.png)<br><br>* 根据手册编写代码<br>  * ![img](./README/2D6D9544D21BD4254FDA1856F8782AF5.jpg)<br><br>* `make build` 并使用 `qemu-riscv64` 进行测试<br>  * ![img](./README/F7956AB15C78774A244DEC2C4C2CED91.jpg)<br><br><br>### 1.2~1.6 链接、加载、执行应用程序、实现用户/内核栈、trap管理<br><br>* 根据手册编写代码<br>  * ![img](./README/933AFD3574F1E11075BEA76B09B0D367.jpg)<br><br>### 1.7 编译并运行<br><br>* 编译<br>  * ![img](./README/AC2BC59966528CBB8900CC5996D0D3BC.jpg)<br>* 运行<br>  * ![img](./README/E66A78AA73DBED91F85948AB776E93EC.jpg)<br><br>## 2. 思考问题<br><br>### 2.1 分析应用程序的实现过程，并实现一个自己的应用程序<br><br>#### 2.1.1 分析实现过程<br><br>* 首先，创建一个应用程序的执行环境<br><br>  * `syscall.rs` 实现了该应用程序能够执行的所有系统调用<br>  * `console.rs` 实现了格式化输出<br>  * `lang_items.rs` 实现了语义支持（目前只有异常处理）<br>  * `linker.ld` 实现了内存布局<br>  * `lib.rs` 实现了入口程序：清空bss段，并让_start()跳转到main()<br><br>* 编写应用程序代码<br><br>  * 在 `bin/` 下编写一个只基于上述执行环境的代码即可<br><br>  * `00hello_world.rs` 中 `asm!(\"sret\")` 的作用<br><br>    * `sret` 的作用：`sret` 是RISCV架构中的一个指令，用于在异常处理中，从内核态返回到用户态。<br>    * 这个语句的作用：执行一条非法指令，检测内核是否正确实现。<br>    * 执行 `asm!(\"sret\")`，出现：<br><br>      ```<br>      [kernel] IllegalInstruction in application, core dumped.<br>      ```<br><br>    * 注释 `asm!(\"sret\")`，出现：<br><br>      ```<br>      [kernel] Application exited with code 0<br>      ```<br>    <br>  * `01store_fault.rs`<br><br>    * 这段代码试图往地址0x0的内存处写入数据，被内核中断。<br>    * 这个代码和 `00hello_world` 中的 `asm!(\"sret\")` 的作用类似，用于测试内核是否正确实现了内存保护之类的功能<br><br>  * `02power.rs`<br><br>    * 这段代码用朴素的 $O(n)$ 算法计算了 $3^n \\ \\% \\ 10007, n \\leq 1e5$，并输出了指定的 $10$ 个值<br><br>* 编译与执行<br><br>  * 编写 `Makefile` 并执行<br>  * 可以使用 `qemu-riscv64` 进行测试，确保应用程序执行正确<br><br><br>#### 2.1.2 实现一个自己的应用程序<br><br>* `03quick_power.rs`<br><br>  * 作为算法竞赛选手，所以我想先实现一个 $O(logn)$ 的快速幂算法<br><br>  * 计算内容同 `02power.rs`，但 $n$ 扩大到了 $1e18$<br><br>  * 代码如下<br><br>    ```rust<br>    #![no_std]<br>    #![no_main]<br>    #[macro_use]<br>    extern crate user_lib;<br>    <br>    fn quick_power(base: u64, expo: u64, modu: u64) -> u64 {<br>        let mut a: u64 = base;<br>        let mut n: u64 = expo;<br>        let mut ans: u64 = 1;<br>        while n >= 1 {<br>            if (n & 1 != 0) { ans = ans * a % modu; }<br>            a = a * a % modu;<br>            n >>= 1;<br>        }<br>        ans<br>    }<br>    <br>    #[no_mangle]<br>    fn main() -> i32 {<br>        const P: u32 = 3;<br>        const STEP: usize = 1_000_000_000_000_000_000; // 1e18<br>        const MOD: u32 = 10007;<br>        println!(<br>            \"quick_power: {} ^ {} % {} = {}\",<br>            P, STEP, MOD,<br>            quick_power(P as u64, STEP as u64, MOD as u64)<br>        );<br>        0<br>    }<br>    ```<br><br>  * 编译执行<br><br>    * ![image-20231117183038874](./README/image-20231117183038874.png)<br>    * 竟然什么都不用修改就直接在内核中执行成功了！？<br><br>* `04interactive_power.rs`<br><br>  * 添加了标准输入功能<br>  * 修改了很多代码之后，编译执行，成功了<br>    * ![image-20231117192224051](./README/image-20231117192224051.png)<br>    * ![image-20231117192042585](./README/image-20231117192042585.png)<br>    * ![image-20231117192200829](./README/image-20231117192200829.png)<br><br>### 2.2 分析应用程序的链接、加载和执行过程<br><br>#### 2.2.1 链接<br><br>* `os/build.rs`<br><br>* 在rust中，`build.rs` 是一个用于构建代码的文件。这里，我们的代码直接使用了rust标准库内的函数和宏。这是因为，`build.rs` 只用于预处理，不涉及编译后的操作系统内核，所以我们可以在 `build.rs` 中任意使用库函数。<br><br>* 该脚本往标准输出流中输出了以下内容<br><br>  * ![image-20231117193755791](./README/image-20231117193755791.png)<br><br>  * 这里前两行说明，如果 `/user/src` 或 `/user/target/riscv.../release` 目录下有文件变更，那么就重新build<br><br>    * **我发现了文档代码中的一个bug**<br><br>      * 这两行的作用是，如果 `user` 有变更，则重新编译 `os`<br>      * 但是，此时 `user` 并没有被重新编译，`os` 使用 `user` 旧的编译结果 进行编译，这仍然会使得 `os` 编译出的结果没有被更新<br><br>      * 解决方法<br><br>        * 往 `build.rs` 中添加如下内容：<br><br>        ```rust<br>        use std::process::{Command, Output};<br>        <br>        fn main() {<br>            println!(\"cargo:rerun-if-changed=../user/src/\");<br>            // println!(\"cargo:rerun-if-changed={}\", TARGET_PATH);<br>            rebuild_user().unwrap();<br>            insert_app_data().unwrap();<br>        }<br>        <br>        fn rebuild_user() -> Result<Output> {<br>            let mut cmd = Command::new(\"make\");<br>            cmd.arg(\"--directory\").arg(\"../user\").arg(\"build\");<br>            cmd.output()<br>        }<br>        ```<br><br>* 该脚本包含了以下内容<br><br>  * 设置了当 `user/src` 有修改时，重新执行该脚本<br><br>  * 读取 `user/src/bin` 下的所有代码文件，并按名称排序<br><br>  * 生成了 `os/target/riscv.../release/build/os-.../output` 文件，里面存储了编译脚本<br><br>    ```<br>    cargo:rerun-if-changed=../user/src/<br>    app_0: 00hello_world<br>    app_1: 01store_fault<br>    app_2: 02power<br>    app_3: 03quick_power<br>    app_4: 04interactive_power<br>    ```<br><br>  * 生成了 `os/src/link_app.S` 文件，指定了应用程序二进制码的位置和相关的信息，在 `main.rs` 中被调用<br>  <br>    * `link_app.S` 这个汇编代码最为关键！（我理解了好久）<br>    * 首先，这段代码定义了 `_num_app` 这个外部符号，并在此符号之后按顺序存入：app个数、第0个app的起始地址、第1个app的起始地址、......、最后一个app的起始地址、最后一个app的结束地址<br>    * 接着，这段代码按顺序定义了每个app的起始地址和结束地址，并在之间以二进制形式载入了每个app的 `.bin` 文件，供其他代码直接执行。<br>    * `incbin` 语句在编译期将app的二进制文件读取进内存<br>  <br><br>#### 2.2.2 加载<br><br>* `os/src/batch.rs` 的 `lazy_static! {}` 部分<br>  * 这部分代码对 `link_app.S` 进行了解析<br>  * 这段代码首先获取app个数，接着将每个app和对应数据储存进 AppManagerInner<br>  * 这段代码声明了函数 `_num_app`，而这个函数的签名和 `link_app.S` 中的外部符号 `_num_app` 相对应！所以就可以读取对应值了。接着读取每个app数据的起始地址，然后按顺序读取内容<br>  * 读取完毕后，便成功以二进制形式加载了应用程序<br><br><br>#### 2.2.3 执行<br><br>* `os/src/batch.rs` 的 `load_app()` 函数<br>  * 这个函数读取了 `app_id` 的对应app，并且将该app的数据复制到 `APP_BASE_ADDRESS` 地址处<br>  * 该地址为 `0x80400000` 和应用程序的入口地址相对应！太酷了！<br><br>#### 2.2.4 总结<br><br>* 总的来说<br>  * 通过 `build.rs` 生成 `link_app.S` 链接应用程序的二进制数据，通过 `.incbin` 语句在编译器把二进制数据读取进内存<br>  * 通过 `batch.rs: lazy_static!{}` 将数据读取进内存的特定位置<br>  * 通过 `batch.rs: load_app()` 将数据读取到 `0x80400000` 地址，从而执行代码<br><br>### 2.3 分析Trap是如何实现的？<br><br>* trap模块实现了应用程序的系统调用和异常处理。<br><br>* 以下内容摘自实验文档：<br><br>  > Trap处理的流程大致如下：首先通过将 Trap上下文保存在内核栈上，然后跳转到trap处理函数完成 Trap 分发及处理。当处理函数返回之后，再从保存在内核栈上的Trap上下文恢复寄存器。最后通过一条 sret 指令回到应用程序继续执行。<br><br>* `os/src/trap/context.rs`<br><br>  * 该文件定义了Trap上下文<br><br>* 某个应用程序执行系统调用（ecall），从 **用户态进入内核态**<br><br>* `os/src/trap/trap.S: __alltraps`<br><br>  * 该函数将Trap上下文保存在内核栈上。在函数最后，再调用 trap_handler<br><br>* `os/src/trap/mod.rs: trap_handler`<br><br>  * 该函数从CSR寄存器中读取异常状态，并进行异常处理<br><br>* `os/src/trap/trap.S: __store`<br><br>  * 该函数在 `batch.rs: run_next_app()` 中被调用，用于从内核栈的trap上下文中回复状态。在函数最后，再执行 sret，从 **内核态切换回用户态**<br><br>## 3. Git提交截图<br><br>* [仓库链接](https://github.com/YXHXianYu/GardenerOS)<br>* ![image-20231117220746018](./README/image-20231117220746018.png)<br><br>## 4. 其他说明<br><br>* 太酷了！<br>* 读懂代码的过程非常爽！<br>');
INSERT INTO `problem` VALUES ('b134fc5b-5840-4940-a211-fad3d926a5ff', '我的GAMES101计算机图形学学习笔记', '', 'Computer Graphics Summary<br><br>> YXH咸鱼的总结笔记<br><br>***<br><br>## Linear Algebra 线性代数<br><br>#### Vector 向量<br><br>* Normalization<br>* Addition<br>  * Geometrically : Parallelogram law & Triangle law<br>  * Algebraically : Simply add coordinates<br>* Cartesian Coordinate<br>* Multiplication<br>  * **Dot Product**<br>    * $<br>      \\vec{a}\\cdot\\vec{b}=||\\vec{a}||\\ ||\\vec{b}||\\ cos(\\theta)\\\\<br>      cos(\\theta)=\\tfrac{\\vec{a}\\cdot\\vec{b}}{||\\vec{a}||\\ ||\\vec{b}||}<br>      $<br><br>  * **Cross Product**<br>    * $<br>      长度定义：||\\vec{a}\\times\\vec{b}||=||\\vec{a}||\\                 ||\\vec{b}||\\sin(\\phi)\\\\<br>      方向定义：右手螺旋定则：四指由\\vec{a}旋转向\\vec{b}，大拇指方向即结果向量方向\\\\<br>      交换律: \\vec{a}\\times\\vec{b}=-\\vec{b}\\times\\vec{a}\\\\<br>      \\vec{a}\\times\\vec{a}=0<br>      $<br><br>#### Matrices 矩阵<br><br>* Matrix-Matrix Multiplication<br><br>  * $$<br>    (M\\times N) (N \\times P) = (M \\times P)\\\\c[i,j] = \\sum_{1\\le k\\le N}(a[i,k]\\times b[k,j])<br>    $$<br><br>* Matrix-Vector Multiplication<br><br>* Transpose of a Matrix<br><br>  * Switch rows and columns<br><br>* Identity Matrix and Inverses<br><br>  * $$<br>    xI_{3\\times 3} = \\left (\\begin{array}{ccc}1 & 0 & 0\\\\0 & 1 & 0\\\\0 & 0 & 1\\\\\\end{array}\\right)\\\\AA^{-1} = A^{-1}A = I\\\\(AB)^{-1}=B^{-1}A^{-1}<br>    $$<br><br>* Vector multiplication in Matrix from<br><br>  * Dot product<br>  * Cross product<br><br>***<br><br>## Transformation 变换<br><br>#### 2D Transformations 二维变换<br><br>* Scale Matrix<br><br>  * $<br>    \\begin{bmatrix}<br>    x^{\'}\\\\y^{\'}<br>    \\end{bmatrix}<br>    =<br>    \\begin{bmatrix}<br>    s_x & 0\\\\0 & s_y<br>    \\end{bmatrix}<br>    \\begin{bmatrix}<br>    x\\\\y<br>    \\end{bmatrix}\\begin{bmatrix}<br>    x^{\'}\\\\y^{\'}<br>    \\end{bmatrix}<br>    =<br>    \\begin{bmatrix}<br>    s_x & 0\\\\0 & s_y<br>    \\end{bmatrix}<br>    \\begin{bmatrix}<br>    x\\\\y<br>    \\end{bmatrix}<br>    $<br><br>* Reflection Matrix<br><br>  * $<br>    \\begin{bmatrix}x^{\'}\\\\y^{\'}\\end{bmatrix}=\\begin{bmatrix}-1 & 0\\\\0 & 1\\end{bmatrix}\\begin{bmatrix}x\\\\y\\end{bmatrix}<br>    $<br><br>* Shear Matrix<br><br>  * $<br>    \\begin{bmatrix}x^{\'}\\\\y^{\'}\\end{bmatrix}=\\begin{bmatrix}1 & a\\\\0 & 1\\end{bmatrix}\\begin{bmatrix}x\\\\y\\end{bmatrix}<br>    $<br><br>* Rotate Matrix<br><br>  * 我直接自己推出来了，耶！不愧是我 (✿◡‿◡)<br><br>    - \"由特殊到一般\"<br><br>  * $\\mathbf{R_\\theta} =<br>    \\begin{bmatrix}<br>    \\cos\\theta&-\\sin\\theta\\\\<br>    \\sin\\theta&\\cos\\theta<br>    \\end{bmatrix}<br>    $<br><br>  * $\\mathbf{R_{-\\theta}}=\\mathbf{R^{T}_{\\theta}}$<br><br>  * $\\mathbf{R_{-\\theta}}=\\mathbf{R^{-1}_{\\theta}}\\ (by\\ \\ definition)$ <br><br>#### Homogeneous Coordinates 齐次坐标系<br><br>* 通过增加一个矩阵维度w，把所有线性变换统一为一个矩阵<br>  * 2D Point = $(x,y,1)^T$<br>  * 2D Vector = $(x,y,0)^T$<br>* 增加w维度后，平移变换可以和其他旋转等变换统一<br>  * 因为向量具有平移不变性，所以对向量做平移变换，不改变向量自身。<br>    * 向量受平移变换影响，所以w为0，不受影响。<br>    * 点受平移变换影响，所以w不为0，受影响。<br>* 2D 齐次坐标系中，$\\left( \\begin{array}{c} x\\\\y\\\\w \\end{array} \\right) =\\left( \\begin{array}{c} x/w\\\\y/w\\\\1 \\end{array} \\right), w \\ne 0$<br>* Inverse Transform   <=>   Inverse Matrix<br>  * 逆变换 同 逆矩阵<br>* Composite Transform<br>  * 可以把许多变换压成一个单一矩阵<br><br>#### 3D Transformation 三维变换<br><br>* Rotation around x-, y-, z-axis<br><br>* y轴旋转因为坐标系的定义(左右手)和叉乘，所以形式和x/z轴不同<br><br>* **Rodrigues\' Rotation Formula 罗德里格旋转公式**<br><br>  * $R(n, \\alpha) 表示 n轴旋转\\alpha°$<br><br>$$<br>\\textbf{K} = <br>\\begin{bmatrix}<br>0 & -n_z & n_y\\\\<br>n_z & 0 & -n_x\\\\<br>-n_y & n_x & 0<br>\\end{bmatrix}<br>\\\\<br>\\textbf{R}(\\vec{n},\\alpha)<br>= I<br>+ sin(\\alpha)K<br>+ (1-cos(\\alpha))K^2<br>$$<br><br>* GAMES101默认中为 左手系<br><br>***<br><br>## Viewing Transformation 视角变换<br><br>* **View / Camera Transformation**<br><br>* MVP(model view projection) Transformation<br><br>* Define the camera<br>  * Position $\\vec{e}$<br>  * Look-at / gaze direction $\\hat{g}$<br>  * Up direction $\\hat{t}$<br><br>* Transform the camera to<br><br>  - The origin, up at Y, look at -Z<br><br>* **Perspective Transformation**<br>  $$<br>  \\begin{bmatrix}<br>  n & 0 & 0 & 0\\\\<br>  0 & n & 0 & 0\\\\<br>  0 & 0 & n+f & -nf\\\\<br>  0 & 0 & 1 & 0<br>  \\end{bmatrix}<br>  $$<br><br><br>***<br><br>## Rasterization 光栅化<br><br><br><br>#### Anti-aliases<br><br>* 傅里叶级数展开<br>  - Represent a function  as a weighted sum of sines and cosines.<br>  - 任何一个周期函数都可以用一系列正余弦函数的线性组合表示<br>* 傅里叶变换<br>  - 多项式 转换为 极坐标下的点集？<br>  - 时域 变为 频域<br>* Aliases（走样）<br>  - 同一个采样方法采样两种不同频率的函数，得出来的结果无法区分<br>* Filtering<br>  - 高频滤波（此处，图片转频域，高通滤波器，转回图片）<br>  - ![6-1](I:\\计算机图形学\\GAMES101闫\\pic\\6-1.png)<br>  - 高频：边界处，变化大有断层，就可以看成高频<br>  - 同理，还有低通滤波器，或者低频高频一起滤<br>  - Filtering = Convolution (= Averaging)<br>* 卷积定理： <br>  - 时域上卷积 等价于 频域上乘积<br>  - 时域上乘积 等价于 频域上卷积<br>* Reduce Aliasing Error<br>  - Option 1: increasing sampling rate<br>  - Option 2: Antialiasing<br>    - 先模糊 (低通滤波)，再采样<br>      - 模糊：用小盒子滤波器对图像取平均（要处理边界像素的亮度）<br>      - 采样：判断像素是否在三角形内<br>* MSAA：Multisampling / Supersampling<br>  - 作用：模糊图像，并对图像进行采样<br>  - 内容：把1个像素划分成 $n$ 小像素，再求出 $m$ 个像素点在三角形内，则像素覆盖率为 $\\frac{n}{m} \\times 100\\%$ <br>  - 缺点：增大计算量，速度慢<br>  - 重点：SSAA和MSAA的不同是什么？<br>* FXAA：Fast Approximate AA<br>  - 找到图像边界，用无锯齿图像替换有锯齿边界<br>* TAA：Temporal AA (po重音)<br>  - 找上一帧来进行抗锯齿<br>* Super resolution / super sampling (超分辨率/超级采样)<br>  - DLSS（Deep Learning Super Sampling）<br><br>***<br><br>## Shading 着色<br><br>#### Visibility 可见性<br><br>* Painter\'s Algorithm 画家算法<br>  * 时间复杂度 O(nlogn + n)<br>  * 无法处理 “A叠B、B叠C、C叠A” 的情况<br>  * ![7-1](pic\\7-1.png)<br>* Z-Buffer 深度缓存<br>  * 时间复杂度 O(n)<br>  * ![8-1](pic\\7-2.png)<br><br>#### Blinn-Phong Reflection Model 布林冯反射模型<br><br>* 光照 = 环境光Ambient + 漫反射Diffuse + 高光Specular<br>  * ![8-3](pic\\8-3.png)<br>* Diffuse<br>  * $L_d$ = $k_d$ $\\cdot$ $(I/r^2)$ $\\cdot$ $max(0, \\vec{n}\\cdot \\vec{l})$<br>* Specular<br>  * $L_s = k_s\\cdot(I/r^2)\\cdot max(0,\\vec{n}\\cdot\\vec{h})$<br>    * 这里点乘的$cos(\\theta)$的次数需要为100+，来实现高光只有一小部分的特点<br>* Ambient<br>  * $L_a = k_aI_a$<br>* 和**Phong Reflection Model**的区别在于光线与观测角度差的计算方法<br><br>#### Shading Frequencies 着色频率<br><br>* **Flat** Shading<br>  - 计算 **三角形(面)** 法线，三角形光照直接计算得到<br>* **Gouraud** shading<br>  - 计算 **点** 的法线，三角形光照对顶点光照取均值<br>  - 顶点法线 取 关联的面的法线 的 加权平均值<br>* **Phong** shading<br>  - 计算 **像素** 的法线<br>  - 所有法线都是单位向量，需要 **归一化**<br>* ![8-4](pic\\8-4.png)<br><br>#### Graphics Pipeling (Real-time Rendering) 图形管线<br><br>* Pipeline 管线<br>  * 概念：三维模型经过一系列操作渲染到二维平面上的 **一系列操作**<br>  * 流程<br>    1. Vertex Processing<br>    2. Triangle Processing <br>    3. Rasterization 光栅化<br>    4. Fragment Processing <br>    5. Framebuffer Operations <br>* Shader 着色器<br>  * 推荐网站 : [Shadertoy](http://shadertoy.com/view/ld3Gz2)<br><br>#### Texture mapping 纹理映射<br><br>#### Barycentric coordinates 重心坐标<br><br>* 注意点：重心坐标没有投影不变性<br>  * 所以三维空间的属性需要在三维空间中做插值。<br><br>#### Texture antialiasing (Mipmap)<br><br>* 纹理过小 与 纹理过大<br><br>#### Applications of Texture<br><br>* Environment Map 环境光照<br>  * 注：认为所有光照来自无限远<br>  * Spherical Map ：描述来自不同方向的环境光信息(在一个球的表面)<br>  * Cube Map ：描述来自不同方向的环境光信息(在一个立方体的表面(沿球心连线延长))<br>* Bump Mapping (凹凸贴图)<br><br>***<br><br>## Geometry 几何<br><br>#### Explicit 显式<br>1. Point Cloud 点云 (explicit) <br><br>   1. 可以用特别密集的点云来表示模型<br>   2. 常用于扫描得到的数据<br><br>2. Polygon Mesh(explicit)<br><br>   1. 最广泛应用的显式表示<br><br>3. The Wavefront Object File (.obj)  Format<br><br>   1. 储存一个模型的文件<br><br>   2. 例如，储存一个立方体<br><br>      1. 顶点坐标<br>      2. 纹理坐标<br>      3. 法线<br>      4. 哪3个点组成1个三角形（参数：第i个顶点，第j个纹理坐标，第k个法线）  <br><br>#### Curves 曲线<br>1. Camera Path<br>2. Animation Curves<br>3. Vector Fonts 矢量字体<br><br>#### Bezier Curves 贝塞尔曲线（implicit）<br>* 用一系列控制点来定义曲线<br>* Evaluating Bezier Curves<br>  * de Casteljau Algorithm<br>    * 递归找bn和bn+1之间位于t的点<br>    * 插值<br>    * 代数：给n+1个控制点，可以得到一个n阶的贝塞尔曲线....<br>  * Bernstein Polynomials<br>* Properties<br>  * 过起末点<br>  * 切线<br>  * 反射后的控制点得出的贝塞尔曲线不变<br>  * 贝塞尔曲线在控制点形成的凸包(Convex Hull)内<br>* Beziewise Bezier Curves<br>  * 每n个控制点定义一个贝塞尔曲线（大家喜欢n=4）<br>  * 连接点和前后两个控制点，三点共线（最好连接点到两个控制点距离相等，大家喜欢的额外定义）（三点共线：C0连续(continuity) ）（三点共线且距离相等：C1连续）（cn即n阶导）<br>* Splines 样条<br>  * 一个可控的曲线<br>* B-splines B样条<br>  * 极其复杂<br>  * NURBS 非均匀游离B样条<br><br>***<br><br>## Ray Tracing 光线追踪<br><br>* Why Ray Tracing?<br>  * Rasterization couldn\'t handle **global** effects well<br>    * Soft shadows<br>    * Glossy reflection<br>    * Indirect illumination<br>  * Rasterization is fast, but quality is relatively low<br><br>* Light Rays<br>  * Three ideas about light rays<br><br>     1. Light travels in straight lines<br><br>     1. Light rays do not \"collide\" with each other if they cross<br><br>     3. Light rays travel from the light sources to the eye<br><br>        \"And if you gaze long into an abyss, the abyss also gazes into you.\" -- Nietzsche (translated)<br><br>* Ray Casting<br>  * Pinhole Camera Model<br>    * 眼睛对每个像素发出一条光线，交于最近的物体的一点<br>    * 该点对光源连线，并着色<br><br>![11-1](pic\\11-1.png)<br><br>### Whitted-Style Ray Tracing<br><br>#### Recursive Ray Tracing **递归**的光线追踪<br><br>* Whitted-Style光线追踪就是在模拟光线不断投射的过程<br><br>* 如何计算光线与球面的交点？<br><br>  - 定义光线 : $\\textbf{r}(t) = \\textbf{o}+t\\textbf{d},\\ 0 \\leq t \\leq \\infty $<br>    - 光线被 它的起点o 和 一个向量d 定义<br>  - 定义平面: $\\textbf{p}:(\\textbf{p}-\\textbf{c})^2-R^2=0$<br><br>  * 交点 : $(\\textbf{o}+t\\textbf{d}-\\textbf{c})^2-R^2=0$<br>  * 作为二次函数，即 $ at^2 + bt + c = 0 $<br>    * $ a = \\textbf{d} \\cdot \\textbf{d} $<br>    * $ b = 2(\\textbf{o} - \\textbf{c}) \\cdot \\textbf{d} $<br>    * $ c = (\\textbf{o} - \\textbf{c}) \\cdot (\\textbf{o} - \\textbf{c}) - R^2 $<br>    * $ t = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $<br><br>* 如何计算光线与隐式表面的交点？<br><br>  * General implicit surface : $ \\textbf{p} : f(\\textbf{p}) = 0 $<br>  * Substitute ray equation : $ f(\\textbf{o}+t\\textbf{d}) = 0 $<br>  * Solve for **real, positive** roots<br><br>* 如何计算光线与显式表面的交点？<br><br>  * 问题：根据交点数量的奇偶性，来判断点是否在模型内：如果光线切于模型怎么办？<br>  * 最暴力的方法：枚举每个三角形，并且判断是否相交<br><br>* 如何得出光线和三角形的交点？<br><br>  * 分解问题：1.光线和平面求交；2.交点是否在三角形内<br>    * 定义平面：一个法线$\\textbf{N}$ + 一个点$\\textbf{p\'}$<br>      * 平面上任意一个点P满足：$ (\\textbf{p} - \\textbf{p\'}) \\cdot \\textbf{N} = 0 $<br>      * 得到一个平面方程 $ ax+by+cz+d = 0 $<br>    * 交点：$ (\\textbf{o}+t\\textbf{d} - \\textbf{p\'}) \\cdot \\textbf{N} = 0 $<br>      * 一次方程，解出 t，检查 t 存在<br>  * **Moller Trumbore Algorithm**<br>    * 联立 光线方程 和 三角形重心坐标方程<br>      * 未知数：时间t，重心坐标b1,b2（b3 = 1-b1-b2)<br>      * 空间中三维坐标，三个方程组<br>      * 三个方程三个未知数，可解<br>      * t 为正数，b1、b2、b3均非负数，则光线与三角形存在交点<br>      * 可以利用高斯消元求解（复杂度高）<br>      * 可以利用本算法(基于Cramer法则/矩阵行列式=三个列向量的混合积)求解<br>        * 推导：https://blog.csdn.net/zhanxi1992/article/details/109903792<br><br>* 如何加速得出光线和表面的交点？<br><br>  * Bounding Volumes/Box 包围体积/盒<br>    * 如果光线连包围盒都碰不到，那里面的东西根本不用看<br>  * **Axis-Aligned Bounding Box (AABB) 轴对齐包围盒**<br>  * 如何得出光线和轴对称包围盒的交点<br>    * 对每个对面计算出$t_{min}$和$t_{max}$（利用光线和平面相交的判断方法）<br>    * 光线进入盒子的时间$t_{enter}=max(t_{min})$，光线离开盒子的时间$t_{exit}=min(t_{max})$<br>    * 如果$t_{enter}<t_{exit}$，则光线存在一段时间进入盒子；<br>    * 如果$t_{exit} < 0$，则盒子在光线背后；<br>    * 如果$t_{exit}>=0 \\ \\ and\\ \\  t_{enter}<0$，则起点在盒子里，光线在盒子里，存在交点；<br>    * **总结：$ t_{exit}>=0 \\ \\ \\&\\&\\ \\   t_{enter}<t_{exit}$，则光线与盒子相交**<br>  * 轴对齐包围盒的优势，是可以用每个轴的分量来计算相交时间，效率高<br><br>![11-2](pic\\11-2.png)<br><br>#### Spatial Partitions 空间划分<br><br>* Uniform Grids<br>* Spatial Partitioning Examples 空间划分实例<br>  * Oct-Tree : 八叉树（划分立方体为八个子立方体）<br>  * **KD-Tree**：二叉树（每次划分x -> y -> z轴）<br>  * BSP-Tree ：划分面非轴对齐；高维复杂；<br>* Data Structure of KD-Tree<br>  * Internal nodes store<br>    * split axis: x-, y-, or z-axis<br>    * split position: coordinate of split plane along axis<br>    * children: pointers to child nodes<br>    * **No objects are stored in internal nodes**<br>  * Leaf nodes store<br>    * list of objects<br>  * 非叶子结点存KDtree信息，叶子结点存objects列表<br>  * 缺点：<br>    * 判定三角形和AABB是否有交点 --- 这个问题很难解决；<br>    * 一个物体有可能出现在多个叶子节点中；<br><br>#### Object Parititions 模型划分<br><br>* Bounding Volume Hierarchy (BVH)<br><br>  * 把一个包围盒中的物体分成两堆，重新求出包围盒，作为新节点，递归求解。若一个节点中物体足够少，则作为叶子节点。<br>  * 优点：<br><br>    * 性质：一个物体只会出现在一个包围盒/节点中<br>    * BVH比KD-Tree好写，不用涉及复杂三维运算<br>  * 缺点：可能出现相似的包围盒，但是内含三角形不同（不如合并在一起）<br>  * Building BVHs<br>    * How to subdivide a node?<br>      * Choose a dimension to split<br>      * Heuristic #1: Always choose the longest axis in node<br>      * Heuristic #2: Split node at location of **median** object（取位置位于中间的物体划分（取三角型重心的x坐标中位数的三角形））<br>        * 无序数列取第i大的数 - 快速选择算法：时间复杂度O(n)<br>    * Termination criteria?<br>      * Heuristic: stop when node contains few elements (e.g. 5)<br>  * BVH不支持动态场景<br><br>* Data Structure for BVHs<br>  * Internal nodes store<br>    * Bounding box<br>    * Children: pointers to child nodes<br>  * Leaf nodes store<br>    * Bounding box<br>    * List of objects<br>  * Nodes represent subset of primitives in scene<br><br>    * All objects in subtree<br><br>* BVH Travelsal (BVH遍历)<br><br>  * 类似线段树，很基础<br><br>* **Surface Area Heuristic**<br><br>  * According to [BVH with SAH](https://www.cnblogs.com/lookof/p/3546320.html)<br><br>  * BVH加速结构需要考虑两个阶段的工作：Build 和 Traversal<br><br>    1.Build 构建<br><br>    ​	1.1 Principle 原则：每个object的质心包围盒的最长轴 为 划分轴<br><br>    ​	1.2 Strategy 策略：<br><br>    ​		1.2.1 SPLIT_MIDDLE 中点划分<br><br>    ​		1.2.2 SPLIT_EQUAL_COUNT 等量划分<br><br>    ​		1.2.3 SPLIT_SAH 表面积启发式算法划分：<br><br>    ​		  ->  把 **表面积比率** 看作是 **被光线射中的概率** ；<br><br>    ​		  ->  使得 **S(A)/S(C)\\*N(A) + S(B)/S(C)\\*N(B)** 最小<br><br>    ​	1.3 Compact BVH：就是把指针关系改为数组关系，可以优化结构加速遍历<br><br>    2.Traversal 遍历<br><br>### Basic Radiometry 辐射度量学<br><br>* 精确定义光的各种属性和与其他物体的交互，才能模拟出漂亮真实的场景。<br><br>* Radiometry：<br>  * Measurement system and units for illumination<br>  * Perform lighting calculations **in a physically correct manner**<br><br>* 基于几何光照<br><br>  * New terms: Radiant flux, intensity, irradiance, radiance<br><br>* **Radiant Energy**<br>  * Radiant energy is the energy of electromagnetic radiation.<br>  * $Q \\ [J = Joule]$  <br><br>* **Radiant Flux** (Power) <br>  * Radiant flux is the energy emitted, reflected, transmitted or received, per unit time.<br>  * $Φ = \\Large\\frac{dQ}{dt}\\normalsize \\ [W = Watt]\\ [lm = lumen]$<br><br>* **Radiant Intensity**<br><br>  * The radiant (luminous) intensity is the power per unit **solid angle** emitted by a point light source<br>  * $ I(\\omega) = \\Large\\frac{d\\Phi}{d\\omega}\\ \\normalsize[\\Large\\frac{w}{sr}\\normalsize] \\  [\\Large\\frac{lm}{sr} \\normalsize =  cd = candela] $<br><br>* **Angles and Solid Angles**<br><br>  * Angle: ratio of subtended arc length on circle to radius<br>    * $ \\theta = \\Large \\frac l r $<br>    * Circle has $ 2\\pi $ **radians**<br>  * **Solid angle**: ratio of subtended area on sphere to radius squared<br>    * $ \\Omega = \\Large \\frac A {r^2} $<br>    * Sphere has $ 4\\pi $ **steradians**<br>  * $ dA = (r \\ d\\theta)(r\\ sin\\theta\\ d\\phi) =r^2\\ sin\\theta\\ d\\theta\\ d\\phi$<br>    * $ \\theta,\\ \\phi $ 分别是表示球上单位向量的角度<br>  * 微分立体角 $ d\\omega = \\Large\\frac{dA}{r^2}\\normalsize=sin\\theta\\ d\\theta\\ d\\phi $<br>  * 如果一个点光源均匀向外辐射光线，根据积分，每个方向光线的intensity: $ I = \\Large\\frac{\\Phi}{4\\pi} $<br><br>* **Irradiance**<br>  * The irradiance is the power per (perpendicular/projected) unit area incident on a surface point.<br>  * $ E(x) = \\Large\\frac{d\\Phi(x)}{dA} \\normalsize\\ [\\Large\\frac{W}{m^2}\\normalsize]\\ [\\Large\\frac{lm}{m^2}\\normalsize=lux] $<br>  * 只考虑垂直于平面的入射光的能量<br>    * **Lambert\'s Cosine Law** 若入射光线不垂直于平面，需要投影到垂直方向<br>  * Correction: **Irradiance** Falloff<br>    * 一根极细光锥传播时，对应的Solid Angle不变，则Intensity不变；随着传播距离(半径)增大，Irradiance逐渐衰减。<br>    * 故光线传播不改变Intensity，改变Irradiance<br><br>* **Radiance**<br><br>  * The radiance is the power emitted, reflected, transmitted or received by a surface, per unit solid angle, per projected unit area.<br>  * $ L(p, \\omega) = \\Large \\frac{d^2\\Phi(p,\\omega)}{d\\omega\\ dA\\ cos\\theta} \\normalsize $<br>  * Incident Radiance<br>    * Irradiance per solid angle<br>    * $ L(p, \\omega) = \\Large \\frac{dE(p)}{d\\omega\\  cos\\theta} \\normalsize $<br>  * Exiting Radiance<br>    * Intensity per projected unit area<br>    * $ L(p, \\omega) = \\Large \\frac{dI(p,\\omega)}{dA\\ cos\\theta} \\normalsize $<br>  * **Irradiance & Radiance**<br>    * $dE(p,\\omega)=L_i(p,\\omega)\\ cos\\theta\\ d\\omega$<br>    * ​       $E(p)=\\Large\\int_{\\normalsize H^2}\\normalsize L_i(p,\\omega)\\ cos\\theta\\ d\\omega$<br>    * Unit hemisphere: $H^2$<br><br>* **Bidirectional Reflectance Distribution Function (BRDF)**<br>  $$<br>  f_r(\\omega_i \\rightarrow \\omega_r)<br>  = \\frac{dL_r(\\omega_r)}{dE_i(\\omega_i)}<br>  = \\frac{dL_r(\\omega_r)}{L_i(\\omega_i)\\ cos\\theta_i\\ d\\omega_i}<br>  \\ [\\frac{1}{sr}]<br>  $$<br><br>  * **The Reflection Equation 反射方程**<br>      * $L_r(p,\\omega_r)=\\Large\\int_{\\normalsize H^2}\\normalsize f_r(p,\\omega_i\\rightarrow\\omega_r)\\ L_i(p,\\omega_i)\\ cos\\theta_i\\ d\\omega_i$<br>  * Challenge: Recursive Equation<br>      * 出射光线由入射光线决定，反射成为一个递归问题<br>  * **The Rendering Equation 渲染方程**<br>      * $L_o(p,\\omega_o)=L_e(p,\\omega_o)+\\Large\\int_{\\normalsize\\Omega+}\\normalsize L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot\\omega_i)\\ d\\omega_i$<br>          * $cos\\theta_i = n\\cdot\\omega_i$<br>      * $L(u) = e(u) + \\int\\ I(v)\\ K(u,v)\\ dv$<br>      * 看作：$L = E + KL$<br>          * 转换为：$L = (I - K)^{-1}E$<br>          * 展开为：$L = E + KE + K^2E + K^3E + ...$<br>      * **Shading in Rasterization**：$L = E + KE$<br>  * **Global Illumination**<br>      * 直接光照(直接光源+单次反射) + 间接光照(多次反射)<br><br>### Probability Review 概率论复习<br><br>* Probability Distribution Function (PDF) 概率密度函数<br>  * $p(x) >= 0 and \\Large\\int\\normalsize p(x) \\ dx=1$<br>  * $E[X] = \\Large\\int\\normalsize x\\ p(x)\\ dx$<br><br>### Monte Carlo Integration 蒙特卡洛积分<br><br>* What & How: Estimate the integral of a function by averaging random samples of the function\'s value.<br>* Monte Carlo Estimator<br>  * Definite integral: $\\Large\\int^b_a\\normalsize f(x)dx$<br>  * Random variable: $X_i\\sim p(x)$<br>  * **Monte Carlo Estimator**: $F_N=\\Large\\frac{1}{N}\\sum\\limits^{N}_{i=1}\\frac{f(X_i)}{p(X_i)}\\normalsize$<br>* **Uniform** Monte Carlo Estimator<br>  * Definite integral: $\\Large\\int^b_a\\normalsize f(x)dx$<br>  * **Uniform** Random variable: $X_i\\sim p(x) = \\Large\\frac{1}{b-a}$<br>    * 随机变量均匀采样 且 均等<br>  * **Basic** Monte Carlo Estimator: $F_N=\\Large\\frac{b-a}{N}\\sum\\limits^{N}_{i=1}\\normalsize f(X_i)$<br>* $F_N=\\Large\\int\\normalsize f(x)dx=\\Large\\frac{1}{N}\\sum\\limits^{N}_{i=1}\\frac{f(X_i)}{p(X_i)}\\normalsize$<br>* Some notes:<br>  * The more samples, the less variance.<br>  * Sample on x integrate on x. 在积分域上采样.<br><br>### Path Tracing! 路径追踪！<br><br>* the Problems of Whitted-Style Ray Tracing<br>  1. Glossy材质的物体不一定全为全反射 [The Utah Teapot]<br>  2. 光线打到Diffuse材质的物体时，应该继续反射，产生**ColorBleeding** [The Cornell box]<br>* the  Rendering Equation involoves<br>  1. Solving an integral over the hemisphere<br>  2. Recursive execution<br>* A Simple Monte Carlo Solution<br>  * The Rendering Equation : $L_o(p,\\omega_o)=\\Large\\int_{\\normalsize\\Omega+}\\normalsize L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot\\omega_i)\\ d\\omega_i$<br><br>    * 省略了发光项<br>  * Monte Carlo integration : $\\Large\\int\\normalsize f(x)dx=\\Large\\frac{1}{N}\\sum\\limits^{N}_{i=1}\\frac{f(X_i)}{p(X_i)}\\normalsize$<br>  * What\'s our \"f(x)\" : $L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot\\omega_i)\\ d\\omega_i$<br>  * What\'s our pdf : $p(\\omega_i)=1/2\\pi$<br><br>    * 半球面<br>  * **In General**<br>    * $L_o(p,\\omega_o)=\\Large\\int_{\\normalsize\\Omega+}\\normalsize L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot\\omega_i)\\ d\\omega_i$<br><br>    * ​                   $\\approx \\Large\\frac{1}{N}\\sum\\limits_{i=1}^{N}\\frac{L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot\\omega_i)}{p(\\omega_i)}$<br><br>    * ````<br>      shade(p, wo)<br>      	Randomly choose N directions wi~pdf<br>      	Lo = 0.0<br>      	For each wi<br>      		Trace a ray r(p, wi)<br>      		If way r hit the light<br>      			Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)<br>      		Else If ray r hit an object at q<br>      			Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)<br>      	Return Lo<br>      ````<br><br>#### Path Tracing<br><br>* Shader<br><br>  ````<br>  shade(p, wo)<br>  	Randomly choose ONE directions wi~pdf(w)<br>  	Trace a ray r(p, wi)<br>  	If way r hit the light<br>  		Return L_i * f_r * cosine / pdf(wi)<br>  	Else If ray r hit an object at q<br>  		Return shade(q, -wi) * f_r * cosine / pdf(wi)<br>  ````<br>   * **路径追踪 N = 1**<br>   * 分布式光线追踪 N > 1<br><br> * Ray Generation<br>   ````<br>     ray_generation(camPos, pixel)<br>     	Uniformly choose N sample positions within the pixel<br>     	pixel_radiance = 0.0<br>     	For each sample in the pixel<br>     		Shoot a ray r(camPos, cam_to_sample)<br>     		if ray r hit the scene at p<br>     			pixel_radiance += 1 / N * shade(p, sample_to_cam)<br>     	Return pixel_radiance<br>   ````<br><br>* Russain Roulette (RR) 俄罗斯轮盘赌<br>  * With probability P, shoot a ray and return the **shading result divided by P: Lo/P**<br>  * With probability 1-P, dont shoot a ray and you\'ll get **0**<br>  * In this way, you can still **expect** to get Lo : $E = P * (Lo / P) + (1 - P) * 0 = Lo$<br>  ````<br>  shade(p, wo)<br>  	Manually specify a probability P_RR<br>  	Randomly select ksi in a uniform dist. in [0, 1]<br>  	If ksi > P_RR<br>  		Return 0.0;<br>  <br>  	Randomly choose ONE directions wi~pdf(w)<br>  	Trace a ray r(p, wi)<br>  	If way r hit the light<br>  		Return L_i * f_r * cosine / pdf(wi) / P_RR<br>  	Else If ray r hit an object at q<br>  		Return shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR<br>  ````<br><br>* Samples per pixel (SPP) 采样率<br><br>* Sampling the Light<br><br>  * $L_o(p,\\omega_o)=\\Large\\int_{\\normalsize\\Omega+}\\normalsize L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)\\ cos\\theta\\ d\\omega_i$<br>  * ​                       $\\Large\\int_{\\normalsize A}\\normalsize L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)\\ \\Large\\frac{cos\\theta\\ cos\\theta\'}{||x\'-x||^2}\\normalsize \\ dA$<br>    * 【应用了积分中的积分域变换，这里不太懂】<br><br>  ````<br>  shade(p, wo)<br>  	# Contribution from the light source.<br>  	Uniformly sample the light at x\' (pdf_light = 1 / A)<br>  	Shoot a ray from p to x\'<br>  	if the ray is not blocked in the middle<br>  		L_dir = L_i * f_r * cosθ * cosθ\' / |x\' - p|^2 / pdf_light<br>  	<br>  	# Contribution from other reflectors.<br>  	L_indir = 0.0<br>  	Test Ruassian Roulette with probability P_RR<br>  	Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi)<br>  	Trace a ray r(p, wi)<br>  	If ray r hit a non-emitting object at q<br>  		L_indir = shade(q, -wi) * f_r * cosine / pdf_hemi / P_RR<br>  	<br>  	Return L_dir + L_indir<br>  ````<br><br>  * 直接光照部分，面光源采样点有很多？那要怎么判断光线是否被blocked<br><br>#### Some Side Notes<br><br>* Path tracing is indeed difficult<br>  * consider it the most challenging in undergrad CS<br>  * Why: physics, probability, calculus, coding<br>  * Learning PT will help you understand in these<br>* Ray tracing: Previous vs. Modern Concepts<br>  * Previous<br>    * Ray tracing == Whitted-style ray tracing<br>  * Modern<br>    * **The general solution of light transport**, including<br>      * (Unidirectional & bidirectional) path tracing<br>      * Photon mapping<br>      * Metropolis light transport<br>      * VCM / UPBP ...<br><br>#### Things we haven\'t covered / won\'t cover<br><br>* 如何在半球上均匀的采样？<br>  * 更通用的，如何采样一个函数？<br>  * sampling<br>* 蒙特卡洛积分如何应用在任意的pdf上？<br>  * importance sampling<br>* Low discrepancy sequences<br>* 如何把半球采样和光线采样结合起来？<br>  * multiple imp. sampling<br>* 每个像素的radiance是否简单平均起来就好了？要不要加权平均？<br>  * pixel reconstruction filter<br>* 如何把radiance转换为颜色？<br>  * gamma correction, curves, color space<br>* **Fear the science**<br>* 《我什么都不会》令闫琪<br><br>***<br><br>## Materials 材质<br><br>* What is Material in Computer Graphics ?<br>  * Material == BRDF<br><br>* Diffuse / Lambertian Material<br>  * $f_r = \\Large\\frac{\\rho}{\\pi}$<br>    * $\\rho$: albedo 反射率(color)<br>* Glossy Material<br>* Perfect Specular Reflection<br>  * $\\omega_o = -\\omega_i +2(\\omega_i\\cdot\\vec{n})\\vec{n}$<br>  * $\\phi_o=(\\phi_i+\\pi)\\ mod\\ 2\\pi$<br>  * $\\omega,\\ \\phi$ 是方位角<br>* **Refraction 折射**<br>  * Snell\'s Law<br>    * $\\eta_i\\ sin\\theta_i = \\eta_t\\ sin\\theta_t$<br>    * $cos\\theta_t=\\sqrt{1-(\\Large\\frac{\\eta_i}{\\eta_t}\\normalsize)^2(1-cos^2\\theta_i)}$<br>    * 当$\\Large\\frac{\\eta_i}{\\eta_t}\\normalsize > 1$时，该式子可能无意义（即该反射为全反射）<br>  * Snell\'s Window / Circle<br>    * $97.2°$<br>    * ![17-1](pic\\17-1.png)<br>* Fresnel Term<br>  * 解释光线中，有多少能量反射，多少能量折射<br>  *  S极化光线 和 P极化光线 的fresnel term不同<br>  * 入射光平行多反射；入射光垂直多折射；<br>  * ![17-2](/pic/17-2.png)<br><br>#### Microfacet<br><br>* Microfacet Theory<br>  * Rough Surface<br>    * Macroscale: flat & rough<br>    * Microscale: bumpy & **specular**<br>  * Individual elements of surface act like **mirrors**<br>    * Known as Microfacets<br>    * Each microfacet has its own normal<br>* Microfacet BRDF<br>  * 微表面的法线分布<br>    * 集中 <=> glossy<br>    * 分散 <=> diffuse<br>  * $f(i, o) = \\Large \\frac {F(i, h)\\ G(i, o, h)\\ D(h)}{4(n, i)\\ (n, o)}\\normalsize$<br>    * $F(i, h)$ : Fresnel term<br>    * $G(i, o, h)$ : shadowing-masking term<br>      * 修正入射角/出射角接近90°(Grazing Angle)的特殊情况<br>    * $D(h)$ : distribution of normals<br>* Isotropic / Anisotropic Materials 各向同性/各向异性 材质<br>  * Anisotropic: $f_r(\\theta_i, \\phi_i;\\theta_r, \\phi_r) ≠ f_r(\\theta_i,\\theta_r,\\phi_r-\\phi_i)$<br>  * Nylon尼龙：介于各向同性与各向异性之间<br>  * Velvet天鹅绒：可以人为地更改微表面，实现各向异性<br>* **Properties of BRDFs**<br>  * Non-negativity：函数值非负<br>  * Linearity：线性<br>  * Reciprocity principle：可逆性<br>    * $f_r(\\omega_r\\rightarrow\\omega_i)=f_r(\\omega_i\\rightarrow\\omega_r)$<br>  * Energy conservation：能量守恒<br><br>* MERL BRDF Database<br>  * 测量不同材质的数据的数据库<br><br>***<br><br>## Advanced Topics in Rendering<br><br>* unbiased 无偏<br><br>  * Monte Carlo积分在任何情况下均为1（无系统误差）<br><br>* biased 有偏<br><br>  * 期望值正确<br><br>* **Bidirectional Path Tracing** (BDPT)<br><br>  * 适合 \"光源被遮罩，整个场景主要被间接光照亮\" 的情况<br>  * 很难写。如果能自己实现BDPT，那自己实现渲染器就没什么问题了<br>  * ![18-1](pic\\18-1.png)<br><br>* **Metropolis Light Transport** (MLT)<br><br>  * 利用Markov Chain根据旧采样样本，在旧样本周围生成新样本<br>  * 适合困难光路的场景<br>  * ![18-2](pic\\18-2.png)<br>  * 缺点：无法算出图像收敛时间；渲染结果会\"dirty\"<br><br>* **Photon Mapping 光子映射**<br><br>  * 特别适合用来渲染 **Caustics**<br><br>  * ![18-3](pic\\18-3.png)<br><br>  * 算法流程<br><br>    * Stage 1 photon tracing：从光源射出光子，一直弹射，直到打到diffuse表面<br><br>    * Stage 2 photon collection：从眼睛射出光路，一直弹射，直到打到diffuse表面<br><br>    * Calculation - local density estimation：<br><br>      ​	对每个渲染点，找最近的N个光子(BVH)，算出所占面积<br><br>  * Why biased?<br><br>    * 现象：产生模糊<br>    * $dN / dA != \\Delta N / \\Delta A$<br>    * 在N相同的情况下，光源射出光子数量越多，$ \\Delta A$ 越接近 $dA$<br><br>  * An easier understanding bias in rendering<br><br>    * biased == blurry<br>    * consistent == con blurry with infinite #samples<br><br>  * 为什么不计算一定面积的光子数量<br><br>    * 结果不收敛，一定有偏，不再Consistent<br><br>* **Vertex Connection and Merging** (VCM)<br><br>  * 结合了双线路径追踪和光子映射<br>* **Instant Radiosity 实时辐射度** (IR)<br><br>  * 把已经被照亮的面积看作新的光源<br><br>***<br><br>## Advanced Appearance Modeling<br><br>* **Participating Media 散射介质**: Fog / Cloud<br>  * Phase Function 相位函数：决定光线如何散射<br>  * Participating Media: Rendering<br><br>* **Hair Appearance**<br>  * Kajiya-Kay Model: 不够优秀，效果还是很假<br>  * Marschner Model: <br>    * 把头发当成玻璃圆柱，内部有不同颜色色素可以吸收颜色；<br>    * 光线分为三种：R/TT/TRT<br>  * **Double Cylinder Model**:<br>    * 闫老师发明的<br>    * Medulla 髓质: 髓质大小影响光线散射<br>    * 加入髓质，形成双层髓质模型<br>    * 光线分为五种：R/TT/TRT/TTs/TRTs<br>    * ![18-4](pic\\18-4.png)<br>    * \"为什么大家用了我的模型后，只能拿奥斯卡最佳视效提名，拿不到最终的奖呢？\"<br>* **Granular Material** 颗粒材质<br>  * 一粒一粒的模型（晶体、糖）<br>* **Subsurface Scattering 次表面散射**<br>  * 应用于：Translucent Material 半透明材质<br>  * 在表面下散射，可以看作BRDF的延申<br>  * Dipole Approximation：将实际光源映射为虚拟光源<br>  * ![18-5](pic\\18-5.png)<br>* **Cloth**<br>  * Render as Surface<br>  * Render as Participating Media<br>  * Render as Actual Fibers<br>* **Details**<br>  * 通过将pdf函数进行干扰，使得模型渲染后出现各种划痕<br>    * 模拟小晶点，也可以通过更改法线分布来实现<br>  * 金属的细节模拟，需要通过波动光学来计算pdf函数<br>    * “波动光学这事讲了要死人的”<br><br>* Procedural Appearance 程序化表面<br>  * 噪声函数<br><br>***<br><br>## Cameras<br><br>* Imaging = Synthesis + Capture<br><br>  * 捕捉成像：用相机拍照<br>* Cameras<br><br>  * Pinholes & Lenses：控制方向<br>  * Shutter 快门：控制光进入<br>  * Sensor 传感器：记录Irradiance信息<br>    * 有人在研究能区分不同方向光的传感器（能记录radiance）<br>  * 光线追踪基于针孔摄像机的模型<br>  * Field of View 视场<br>    * 针孔摄像机可以根据相似三角形来推导FOV<br>    * 大家计算时默认胶片高度35mm，通过改变焦距来改变FOV<br>      * 等效高度35mm，实际高度不一定<br>      * 17mm焦距 <=> wide angle 104°<br>      * 50mm焦距 <=> \"normal\" lens 47°<br>      * 200mm焦距 <=> telephoto lens 12°<br>    * ![19-1](pic\\19-1.png)<br>    * ![19-2](pic\\19-2.png)<br>* Exposure<br><br>  * Exposure = time * irradiance<br>    * ![19-3](pic\\19-3.png)<br>  * Aperture size 光圈大小：改变 **F-Stop (F-Number)** 来控制光圈<br>    * F-Number：Written as FN or F/N；表示 光圈直径的乘法逆元；<br><br>  * Shutter speed 快门速度<br>    * 长快门时间会导致运动模糊 motion blur<br>    * Rolling Shutter：物体运动速度比快门速度快，会造成物体扭曲<br>  * ISO gain 感光度：可以理解成后期对能量乘上某个常数<br>    * 高ISO会导致噪声<br>  * High-Speed Photography<br>    * 快门速度极快 + 大光圈/高ISO<br>  * Long-Exposure Photography<br>    * 延时摄影，拉丝<br>* Thin Lens Approximation<br><br>  * $ \\Large\\frac{1}{f}\\normalsize = \\Large\\frac{1}{z_o}\\normalsize + \\Large\\frac{1}{z_i}\\normalsize$<br>  * $f$ 焦距；$z_o$ object物距；$z_i$ image像距；<br>  * Defocus Blur<br>  * Circle of Confusion<br>    * 一个点经过透镜形成一个圆的像<br>    * $\\Large\\frac{C}{A} = \\frac{d\'}{z_i} = \\frac{|z_s-z_i|}{z_i}$<br>  * $A$ 光圈直径<br>* Depth of Field 景深  <br>  * 景深 就是指 成像清晰的一段范围<br>  * ![19-4](pic\\19-4.png)<br>  * 光圈越小，景深范围越大，清晰的范围越大，模糊效果越小<br><br>***<br><br>## Light Fields 光场<br><br>* Aesthetics (美学) is extremely important!<br>* Light Fields 光场 = Lumigraph 流明图<br>* The Plenoptic Function 全光函数<br>  * the set of all things that we can ever see.<br>  * $P(\\theta, \\phi)$ : 在一个位置上，向所有方向看到的东西<br>  * $P(\\theta, \\phi, \\lambda)$ : 在一个位置上，向所有方向看到的东西和它们的颜色<br>  * $P(\\theta, \\phi, \\lambda, t)$ : 在一个位置上，想所有方向看到的东西和它们的颜色，并且不同时间看到的东西不一样（电影）<br>  * $P(\\theta, \\phi, \\lambda, t, V_x, V_y, V_z)$ : 在一个位置上，想所有方向看到的东西和它们的颜色，并且不同时间看到的东西不一样，并且可以改变观测的位置（全息电影 / 世界） <br>* Light Fields 光场<br>  * Ray：5D -> 4D (在光场函数下)<br>  * 光场：在任何一个位置，往任何一个方向去的光的强度<br>    * 光场是全光函数的一个部分<br>    * 定义在物体表面<br>    * 用2个数表示\"包围盒\"上的一个点，用2个数表示一个方向<br>  * 已知一个物体的光场，可以得到任意位置任意角度观测物体得到的图像<br>  * 2个参数的坐标+2个参数的方向<br>    * -> 2个参数的坐标+2个参数的坐标（用两个平面上的两个点表示光场）<br>* Light Field Camera 光场摄像机<br>  * Lytro: founded by Prof. Ren Ng (UC Berkeley)<br>  * 特性：可以在后期调焦距和光圈大小<br>  * 原理：将成光平面后移，每个像素记录该像素中来自不同方向的光（光场）<br>    * 取不同方向的光线，相当于微移摄像机<br>  * 缺点：分辨率低；高成本(大胶片的高分辨率，微透镜的高精细)<br><br>***<br><br>## Color 颜色<br><br>* Spectral Power Distribution (SPD) 谱功率密度<br><br>  * 线性性质，两个光的谱功率密度拥有可加性<br><br>* 颜色 是 人的感知 (human perception)<br>  * 感官细胞 Photoreceptor Cells<br>    * Rods 棒状细胞：感知光的强度 (灰白)<br>      * ~120 millions rods in eye<br>    * Cones 锥形细胞：感知光的颜色<br>      * 分为 S-Cone、M-Cone、L-Cone<br>      * 三种锥形细胞分别感知不同波长的光线（S短 / M中 / L长 波长）<br>      * 不同人的眼睛中，三中锥形细胞的分布差别巨大<br>      * 人感知到的颜色，是SPD积分后的结果<br>  * Metamers 同色异谱现象<br>    * 同种颜色有着不同SPD<br>    * ![20-1](pic\\20-1.png)<br>    * 可以将一种颜色的光谱进行转换成另一种相同颜色的光谱，便于显示器显示<br>  * 视觉暂留现象<br>    * 可以证明人体成像的补色<br><br>* Color Reproduction / Matching<br>  * Additive Color 加色系统<br>  * CIE RGB Color Matching<br>    * Red 700nm;<br>    * Green 546.1nm<br>    * Blue 435.8nm<br>    * CIE RGB 给出三原色的单波长SPD<br>  * Standardized RGB (sRGB)<br>  * Gamut 色域<br>    * 一种机制能显示的所有颜色<br>  * HSV Color Space<br>    * ![20-2](pic\\20-2.png)<br>  * CMYK 减色系统<br><br>***<br><br>## Animation 动画 / Simulation 模拟<br><br>* Historical Points of Animation<br>  * 岩石壁画<br>    * Shahr-e Sukhteh, Iran 3200 BCE<br>  * 连贯的图像<br>    * Phenakistoscope, 1831<br>  * 用于生物学研究的早期电影<br>    * Edward Muybridge, \"Sallie Gardner\", 1878<br>  * 手绘动画 (First Hand-Drawn Feature-Length(>40min) Animation)<br>    * Disney，白雪公主和七个矮人, 1937<br>  * 数字动画<br>    * Ivan Sutherland, \"Sketchpad\", 1963 - Light pen, vector display<br>    * Ed Catmull & Frederick Parke, \"Computer Animated Faces\", 1972<br>  * CG (Computer Generation)<br>    * Jurassic Park, 1993<br>    * Toy Story, 1995<br>    * Cloudy With a Chance of Meatballs, 2009<br>    * Frozen 2, 2019<br>* Keyframe Animation<br>  * Keyframe Interpolation<br>  * Physical Simulation <br>    * Clothes<br>    * Fluids<br>* Mass Spring System 质点弹簧系统<br>  * Example:<br>    * Mass Spring Rope<br>    * Hair<br>    * Mass Spring Mesh<br>  * A Simple Spring<br>    * Idealized spring<br>      * 长度为零<br>      * $f_{a\\rightarrow b} = k_s(\\vec b - \\vec a)$<br>      * $f_{b\\rightarrow a} = -f_{a\\rightarrow b}$<br>    * Non-Zero Length Spring<br>      * $f_{a \\rightarrow b} = k_s \\Large\\frac{\\vec b - \\vec a} {||\\vec b - \\vec a||}\\normalsize(||\\vec b - \\vec a|| - l)$<br>      * 缺点：弹簧会无限震动下去(无摩擦力, 能量损失)<br>    * Simple motion damping<br>      * $f_b = -k_d\\  \\vec b\'$<br>      * $f_{b} = -k_d\\  \\Large\\frac{\\vec b - \\vec a} {||\\vec b - \\vec a||}\\normalsize \\cdot(\\vec b\' - \\vec a\')$<br>        * 绝对速度 -> 相对速度 -> 相对速度的投影<br>  * Structures from Springs<br>    * Sheets<br>    * Blocks<br>    * Others...<br>    * This structures will not resist shearing<br>    * This structures will not resist out-of-plane(非平面) bending<br>  * Improvements<br>    * pic/21-1<br>  * Aside<br>    * FEM (Finite Element Method) Instead of Springs<br>* Particle Systems 粒子系统<br>  *  把流体当作粒子<br>  *  For each frame in animation<br>     *  [If needed] Create new particles<br>     *  Calculate forces on each particle<br>     *  Update each particle\'s position and velocity<br>     *  [If needed] Remove dead particles<br>     *  Render particles<br>* Kinamatics 运动学<br>  * 正运动学：给出各个关节的状态，算出尖端位置<br>  * 逆运动学：给出尖端位置，反解出各个关节的状态<br><br><br><br><br><br><br><br><br><br>');

-- ----------------------------
-- Table structure for rating
-- ----------------------------
DROP TABLE IF EXISTS `rating`;
CREATE TABLE `rating`  (
  `uuid` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `homeworkUUID` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `userUUID` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `score` float NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE,
  INDEX `homeworkUUID`(`homeworkUUID` ASC) USING BTREE,
  INDEX `userUUID`(`userUUID` ASC) USING BTREE,
  CONSTRAINT `rating_ibfk_1` FOREIGN KEY (`homeworkUUID`) REFERENCES `homework` (`uuid`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `rating_ibfk_2` FOREIGN KEY (`userUUID`) REFERENCES `user` (`uuid`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of rating
-- ----------------------------
INSERT INTO `rating` VALUES ('07df4ed7-a208-445c-83d7-3fc6b4f94403', '142b79db-5528-4d8d-b5cf-c125eaf8c288', '0dbe2bc7-533a-470c-8047-44da0fa5a9a0', 100);
INSERT INTO `rating` VALUES ('1b39d42f-933c-40d8-bb60-d7808a8e0e46', '142b79db-5528-4d8d-b5cf-c125eaf8c288', '2fabe48e-65ad-4564-9f19-2959b9eb5827', -1);
INSERT INTO `rating` VALUES ('1bb4684b-28c6-4ed1-ae89-504a6937b03e', '7875270e-4726-4da3-9070-f4abdbe752f9', 'eb341724-a0f9-41c8-8d21-191f2a632509', 8);
INSERT INTO `rating` VALUES ('1c87d9a8-b43c-463e-97d1-538ef212e8e6', '260bec8b-a5ad-4a5d-83dd-0036e4a18b96', 'eb341724-a0f9-41c8-8d21-191f2a632509', 10);
INSERT INTO `rating` VALUES ('1c9eb0cf-a9ec-47e9-aef1-2848e834c73c', '4d409db2-6a01-40b4-97e3-50c55aec52e9', '3360539a-0c69-4535-982b-16775a6ea1f1', -1);
INSERT INTO `rating` VALUES ('2d266711-2efd-40f4-a26a-595a7ac4f4cd', '9a31a8a6-c482-4ea1-8194-9928458425f8', '3360539a-0c69-4535-982b-16775a6ea1f1', -1);
INSERT INTO `rating` VALUES ('3d9c563b-8a31-40bb-b10e-e8181ba9cdab', '6fdc0263-7d92-4b6d-971c-5c17587d43ee', '50724553-9222-4786-a6dc-844c56efe9e4', -1);
INSERT INTO `rating` VALUES ('5e7d268a-b559-4bd6-b61a-0c2af733da12', '9a31a8a6-c482-4ea1-8194-9928458425f8', 'eb341724-a0f9-41c8-8d21-191f2a632509', 10);
INSERT INTO `rating` VALUES ('5eb4b351-3576-4f41-a2b2-6b6a6aca36f3', '6fdc0263-7d92-4b6d-971c-5c17587d43ee', '2e278e29-537a-4ee9-807b-8fc379abd82d', 50);
INSERT INTO `rating` VALUES ('604aef09-b9a1-4ab0-aa8a-d0410046f91a', '934626a9-5c1a-4dc3-b5cd-33a4126dca0f', '2e278e29-537a-4ee9-807b-8fc379abd82d', -1);
INSERT INTO `rating` VALUES ('698fdbba-09fd-4734-8826-245d32174ffd', '260bec8b-a5ad-4a5d-83dd-0036e4a18b96', '84effa11-e2e0-4514-a0fe-9a893bb4e12e', 11);
INSERT INTO `rating` VALUES ('6aac0214-4544-4177-817b-f3440543099f', '6fdc0263-7d92-4b6d-971c-5c17587d43ee', '56ecfad5-a97f-403f-90bb-b5979bda179e', -1);
INSERT INTO `rating` VALUES ('73ce2534-ca05-4d6a-99eb-28e1e626d3de', 'e09321f1-e06b-4ecc-9fba-58dacc3fb36a', 'eb341724-a0f9-41c8-8d21-191f2a632509', 10);
INSERT INTO `rating` VALUES ('7500337f-2dec-40bb-907a-e5580dc130d2', 'c0c3dbc9-14fa-4797-a5d9-278a7bbd81bf', 'eb341724-a0f9-41c8-8d21-191f2a632509', 15);
INSERT INTO `rating` VALUES ('79ce4171-ffc3-4a4e-90c2-789c428dcb1f', '4d409db2-6a01-40b4-97e3-50c55aec52e9', '2fabe48e-65ad-4564-9f19-2959b9eb5827', -1);
INSERT INTO `rating` VALUES ('7cf81b3f-4d50-4ef4-89ea-78af89598115', '9a31a8a6-c482-4ea1-8194-9928458425f8', '0dbe2bc7-533a-470c-8047-44da0fa5a9a0', 31);
INSERT INTO `rating` VALUES ('7fa98560-11ce-4eb9-a655-d777620fecaf', '260bec8b-a5ad-4a5d-83dd-0036e4a18b96', '2fabe48e-65ad-4564-9f19-2959b9eb5827', -1);
INSERT INTO `rating` VALUES ('819f4ea6-08e1-4c85-892c-851dda8a6133', '142b79db-5528-4d8d-b5cf-c125eaf8c288', '3360539a-0c69-4535-982b-16775a6ea1f1', -1);
INSERT INTO `rating` VALUES ('88027a2d-a378-434f-87cd-aff8149c54ca', '4d409db2-6a01-40b4-97e3-50c55aec52e9', '84effa11-e2e0-4514-a0fe-9a893bb4e12e', 2);
INSERT INTO `rating` VALUES ('a1bc658e-87e5-4043-b4bd-c39343e22129', 'c0c3dbc9-14fa-4797-a5d9-278a7bbd81bf', '56ecfad5-a97f-403f-90bb-b5979bda179e', -1);
INSERT INTO `rating` VALUES ('aafc51fd-2b6f-45ba-99fb-bd66a0386f66', 'e09321f1-e06b-4ecc-9fba-58dacc3fb36a', '84effa11-e2e0-4514-a0fe-9a893bb4e12e', 11);
INSERT INTO `rating` VALUES ('c5c3d846-569d-4e09-ba2f-9ced2e9997ca', '934626a9-5c1a-4dc3-b5cd-33a4126dca0f', 'eb341724-a0f9-41c8-8d21-191f2a632509', 50);
INSERT INTO `rating` VALUES ('cd2462c5-9613-4894-a536-eda7700cec8a', 'c0c3dbc9-14fa-4797-a5d9-278a7bbd81bf', '2e278e29-537a-4ee9-807b-8fc379abd82d', -1);
INSERT INTO `rating` VALUES ('d768d46a-52eb-4b24-bdb4-173b630137b4', 'e09321f1-e06b-4ecc-9fba-58dacc3fb36a', '0dbe2bc7-533a-470c-8047-44da0fa5a9a0', 10);
INSERT INTO `rating` VALUES ('dfc60165-bd94-46d9-9106-003a9ea1222d', '7875270e-4726-4da3-9070-f4abdbe752f9', '50724553-9222-4786-a6dc-844c56efe9e4', -1);
INSERT INTO `rating` VALUES ('e4211973-8ad2-40f4-892b-a1fcfffd9f55', '934626a9-5c1a-4dc3-b5cd-33a4126dca0f', '50724553-9222-4786-a6dc-844c56efe9e4', -1);
INSERT INTO `rating` VALUES ('ead8d825-02d4-48e8-a943-678c68dc57e9', '7875270e-4726-4da3-9070-f4abdbe752f9', '56ecfad5-a97f-403f-90bb-b5979bda179e', -1);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `uuid` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL,
  `username` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `password` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `email` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `authority` int NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE,
  UNIQUE INDEX `unique_username`(`username` ASC) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('0dbe2bc7-533a-470c-8047-44da0fa5a9a0', 'Guest', 'e11c5e0439c2d1797f297ff95af8a9f9', '2943003@qq.com', 0);
INSERT INTO `user` VALUES ('2e278e29-537a-4ee9-807b-8fc379abd82d', 'StudentB', 'e11c5e0439c2d1797f297ff95af8a9f9', '2943003@qq.com', 0);
INSERT INTO `user` VALUES ('2fabe48e-65ad-4564-9f19-2959b9eb5827', 'Student3', 'e11c5e0439c2d1797f297ff95af8a9f9', '2943003@qq.com', 0);
INSERT INTO `user` VALUES ('3360539a-0c69-4535-982b-16775a6ea1f1', 'Student2', 'e11c5e0439c2d1797f297ff95af8a9f9', '2943003@qq.com', 0);
INSERT INTO `user` VALUES ('50724553-9222-4786-a6dc-844c56efe9e4', 'StudentC', 'e11c5e0439c2d1797f297ff95af8a9f9', '2943003@qq.com', 0);
INSERT INTO `user` VALUES ('56ecfad5-a97f-403f-90bb-b5979bda179e', 'StudentA', 'e11c5e0439c2d1797f297ff95af8a9f9', '2943003@qq.com', 0);
INSERT INTO `user` VALUES ('84effa11-e2e0-4514-a0fe-9a893bb4e12e', 'Student1', 'e11c5e0439c2d1797f297ff95af8a9f9', '2943003@qq.com', 0);
INSERT INTO `user` VALUES ('eb341724-a0f9-41c8-8d21-191f2a632509', 'YXH_XianYu', '663e33644c3166a0a75b25169034aefb', '2943003@qq.com', 2);

SET FOREIGN_KEY_CHECKS = 1;
